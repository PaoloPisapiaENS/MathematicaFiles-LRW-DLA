(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
SetOptions[$FrontEndSession,NotebookAutoSave->True]
NotebookSave[]


(* ::Input::Initialization:: *)
Needs["Notation`"]
Notation[NotationTemplateTag[Subscript[\[Beta], a__]] \[DoubleLongLeftRightArrow] NotationTemplateTag[\[Beta][a__]]]
Notation[NotationTemplateTag[Subscript[R, a__]] \[DoubleLongLeftRightArrow] NotationTemplateTag[R[a__]]]
Notation[NotationTemplateTag[Subscript[\[Phi], a__]] \[DoubleLongLeftRightArrow] NotationTemplateTag[\[Phi][a__]]]
Notation[NotationTemplateTag[Subscript[\[Chi], a__]] \[DoubleLongLeftRightArrow] NotationTemplateTag[\[Chi][a__]]]
Notation[NotationTemplateTag[Subscript[\[Psi], a__]] \[DoubleLongLeftRightArrow] NotationTemplateTag[\[Psi][a__]]]
Notation[NotationTemplateTag[Subscript[SuperStar[\[Phi]], a__]] \[DoubleLongLeftRightArrow] NotationTemplateTag[\[Phi]s[a__]]]
Notation[NotationTemplateTag[Subscript[SuperStar[\[Chi]], a__]] \[DoubleLongLeftRightArrow] NotationTemplateTag[\[Chi]s[a__]]]
Notation[NotationTemplateTag[Subscript[SuperStar[\[Psi]], a__]] \[DoubleLongLeftRightArrow] NotationTemplateTag[\[Psi]s[a__]]]
Notation[NotationTemplateTag[SuperStar[\[Phi]]] \[DoubleLongLeftRightArrow] NotationTemplateTag[\[Phi]s]]
{
 {Notation[NotationTemplateTag[SuperStar[\[Chi]]] \[DoubleLongLeftRightArrow] NotationTemplateTag[\[Chi]s]]},
 {Notation[NotationTemplateTag[SuperStar[\[Psi]]] \[DoubleLongLeftRightArrow] NotationTemplateTag[\[Psi]s]]}
}


(* ::Input::Initialization:: *)
Clear[MyGraph];
Options[MyGraph]={"undirected" ->True,"label" ->False};
MyGraph[edges__,root_,source_,OptionsPattern[]]:={Module[{locEdges={},i,locWeights={},locRoot=root,locSource=source,p},
Clear[\[Beta]];

For[i=1, i<=(Dimensions@edges)[[1]],i++,
If[OptionValue["undirected"] && edges[[i,2]] =!=locSource && edges[[i,2]] =!=edges[[i,1]] ,
AppendTo[locEdges,edges[[i,2]]->edges[[i,1]]];
AppendTo[locWeights,\[Beta][edges[[i,2]],edges[[i,1]]] ]
];

If[edges[[i,1]]==locSource,Continue[]];

AppendTo[locEdges,edges[[i,1]]->edges[[i,2]]];
AppendTo[locWeights,\[Beta][edges[[i,1]],edges[[i,2]]] ]
];

locEdges=Sort[locEdges,(#1[[1]]<=#2[[1]] &&#1[[2]]<=#2[[1]])||(#1[[1]]<#2[[2]] &&#1[[2]]<=#2[[2]]) &];

p[\[Beta][a_,b_],\[Beta][c_,d_]]:=1/;(a<=c&&b<=c);
p[\[Beta][a_,b_],\[Beta][c_,d_]]:=-1/;(c<=a&&d<=a);
p[\[Beta][a_,b_],\[Beta][c_,d_]]:=1/;(a<d&&b<=d);
p[\[Beta][a_,b_],\[Beta][c_,d_]]:=-1/;(c<b&&d<=b);
locWeights=Sort[locWeights,p];

(*Print[locEdges];
Print[locWeights]*);

If[ OptionValue["label"],
(*True*)Graph[locEdges,EdgeWeight->locWeights, EdgeStyle->Blue, VertexLabels->{locRoot->ToString[locRoot]<>", ROOT",locSource->ToString[locSource]<>", SOURCE","Name"}, EdgeLabels->"EdgeWeight", VertexStyle->{locRoot->Red,locSource->Green,Blue},EdgeShapeFunction->"FilledArrow"],
(*False*)Graph[locEdges,EdgeWeight->locWeights, EdgeStyle->Blue, VertexLabels->{locRoot->ToString[locRoot]<>", ROOT",locSource->ToString[locSource]<>", SOURCE","Name"}, VertexStyle->{locRoot->Red,locSource->Green,Blue},EdgeShapeFunction->"FilledArrow"]]
],
root(*Root*),source(*Source*)}


(* ::Input::Initialization:: *)
edges = {{1,2},{2,3},{3,1}};
root=2;
source=3;
g=MyGraph[edges,root,source][[1]]


(* ::Input::Initialization:: *)
Clear[DrawOnGraph];
Options[DrawOnGraph]={"drawOthers"-> True};
DrawOnGraph[graph_,path__,OptionsPattern[]]:=Module[{locEdges,locPathStyle={},locRoot,locSource,i},
locEdges = EdgeList@graph;
locRoot = 
 Select[(List@@@PropertyValue[graph,VertexLabels])[[2;;]],StringMatchQ[#[[2]],___~~"ROOT"]&][[All,1]][[1]];
locSource = 
 Select[(List@@@PropertyValue[graph,VertexLabels])[[2;;]],StringMatchQ[#[[2]],___~~"SOURCE"]&][[All,1]][[1]];

For[i=1, i<=Length[path],i++,
AppendTo[locPathStyle,{path[[i,1]]\[DirectedEdge]path[[i,2]]->path[[i,3]]}];
(*Print[locPathStyle]*)
];
If[OptionValue["drawOthers"],
(*True*)Graph[locEdges,EdgeStyle->Flatten@{locPathStyle,Blue}, VertexLabels->{locRoot->ToString[locRoot]",ROOT",locSource->ToString[locSource]",SOURCE","Name"}, VertexStyle->{locRoot->Red,locSource->Green,Blue},EdgeShapeFunction->"FilledArrow"],
(*False*)Graph[locEdges,EdgeStyle->Flatten@{locPathStyle,White}, VertexLabels->{locRoot->ToString[locRoot]",ROOT",locSource->ToString[locSource]",SOURCE","Name"}, VertexStyle->{locRoot->Red,locSource->Green,Blue},EdgeShapeFunction->"FilledArrow"]
]
]


(* ::Input::Initialization:: *)
path1={{2,1,Red},{1,3,Green}};
DrawOnGraph[g,path1]


Clear[DrawFromExpression];
Options[DrawFromExpression]={"graph"->g,"drawOthers"->False};

DrawFromExpression[exp_,OptionsPattern[]]:=Module[{terms,graphs={},i},
terms=exp//.R[a_,b_,c_]^n_->R[a,b,c]//Expand;
terms=List @@ (terms+Zeta[3]);
terms=terms//.\[Beta][__]->1;
terms=DeleteElements[terms,{Zeta[3]}];
terms=Outer[List,terms];
terms=terms//.Times->List;
terms=monoFlatten@@@terms;
terms=terms//.R[a_,b_,c_]->{a,b,c};
(*For[i=1,i<=Length[terms],i++,
terms[[i]]=DeleteElements[terms[[i]],{a_?NumericQ}];
];*)
Print[terms];

For[i=1,i<=Length[terms],i++,
AppendTo[graphs,DrawOnGraph[OptionValue["graph"],terms[[i,2;;]],"drawOthers"->OptionValue["drawOthers"]]];
Print[graphs[[i]]];
Print[Weight ==terms[[i,1]]];
];
]


(* ::Input::Initialization:: *)
Clear[AugmentedGraph];
AugmentedGraph[graph_]:=Module[{locVertices,locEdges,locPathStyle={},locRoot,locSource,newSource,oldSourceNeighbors,graphPlus,i},

locVertices = VertexList@graph;
locEdges = EdgeList@graph/.DirectedEdge->List;
locRoot = 
 Select[(List@@@PropertyValue[graph,VertexLabels])[[2;;]],StringMatchQ[#[[2]],___~~"ROOT"]&][[All,1]][[1]];
locSource = 
 Select[(List@@@PropertyValue[graph,VertexLabels])[[2;;]],StringMatchQ[#[[2]],___~~"SOURCE"]&][[All,1]][[1]];

newSource=locVertices[[-1]]+1;

(*Add the edge from the oldSource to the newSource*)
AppendTo[locEdges,{locSource,newSource}];

(*Add all the edges from the oldSource to its neighbors*)
oldSourceNeighbors=Select[locEdges, #[[2]]==locSource &];

For[i=1,i<=Length[oldSourceNeighbors],i++,
AppendTo[locEdges,{locSource,oldSourceNeighbors[[i,1]]}]
];

graphPlus =MyGraph[locEdges,locRoot,newSource,"undirected"->False][[1]];

Return[graphPlus]
]


(* ::Input::Initialization:: *)
Clear[LaplaceEqSolver];
Options[LaplaceEqSolver]={"BC"->{{},{}} , "selectSolution"->0};

LaplaceEqSolver[graph_,OptionsPattern[]]:=Module[{locVertices,locWeights,totWeights,locRoot,locSource,locBC,equations,variables={},x,solution},
Clear[\[CapitalPhi]];

locVertices = VertexList@graph;
locWeights=WeightedAdjacencyMatrix[graph]//Normal;
totWeights =Total[locWeights,{2}];

locRoot = 
 Select[(List@@@PropertyValue[graph,VertexLabels])[[2;;]],StringMatchQ[#[[2]],___~~"ROOT"]&][[All,1]][[1]];
locSource = 
 Select[(List@@@PropertyValue[graph,VertexLabels])[[2;;]],StringMatchQ[#[[2]],___~~"SOURCE"]&][[All,1]][[1]];

locBC=OptionValue["BC"];

If[locBC=!={{},{}},

AppendTo[locBC[[1]],\[CapitalPhi][locSource]== 1];
AppendTo[locBC[[1]],\[CapitalPhi][locRoot]==0];

AppendTo[locBC[[2]],locSource];
AppendTo[locBC[[2]],locRoot];
];

equations =locBC[[1]] ;

For[x=1,x<=Length[locVertices],x++,
AppendTo[variables,\[CapitalPhi][x]];
If[MemberQ[locBC[[2]],x],Continue[]];
AppendTo[equations, \[CapitalPhi][x]==FullSimplify[Sum[locWeights[[x,y]]/totWeights[[x]] \[CapitalPhi][y],{y,Length[locVertices]}]]]];
(*Print[equations];
Print[variables];*)
solution=Flatten@Solve[equations,variables]/. Rule->List;

If[OptionValue["selectSolution"]!=0,(*True*)
solution=Select[solution,#[[1]]==\[CapitalPhi][OptionValue["selectSolution"]] &][[1,2]]
];

Return[solution]
]


(* ::Input::Initialization:: *)
edges = {{1,2},{2,3},{3,1}};
root=2;
source=3;
g=MyGraph[edges,root,source][[1]];

BC={{\[CapitalPhi][3]==1},{3}};
path1={{2,1},{1,3}};
sol=LaplaceEqSolver[g,"BC"->BC]
Select[sol,#[[1]]==\[CapitalPhi][path1[[1,2]]] &][[1,2]];

sol=LaplaceEqSolver[g,"selectSolution"->1]


(* ::Input::Initialization:: *)
Clear[LaplacianRW];
Options[LaplacianRW]={"draw"->False};
LaplacianRW[graph_,path__,OptionsPattern[]]:=Module[{locSource,locRoot,locWeights,locVertices,denominator,prob=1},
locWeights=WeightedAdjacencyMatrix[graph]//Normal;
locVertices=VertexList@graph;
locRoot = 
 Select[(List@@@PropertyValue[graph,VertexLabels])[[2;;]],StringMatchQ[#[[2]],___~~"ROOT"]&][[All,1]][[1]];
locSource = 
 Select[(List@@@PropertyValue[graph,VertexLabels])[[2;;]],StringMatchQ[#[[2]],___~~"SOURCE"]&][[All,1]][[1]];
If[locRoot =!= path[[1,1]], Print["####  WRONG ROOT  ####"]; Return[NULL]];
If[locSource =!= path[[-1,2]], Print["####  WRONG SOURCE  ####"];Return[NULL]];

Module[{locBC={{},{}},\[Phi],i,\[Phi]sol},
AppendTo[locBC[[1]],\[Phi][locSource]==1];
AppendTo[locBC[[2]],locSource];
For[i=1,i<=Length[path],i++,
AppendTo[locBC[[1]],\[Phi][path[[i,1]]]==0];
AppendTo[locBC[[2]],path[[i,1]]];

(*Print[locBC]*);

\[Phi]sol=LaplaceEqSolver[graph,locBC,\[Phi]];
(*Print[\[Phi]sol]*);

denominator=Sum[locWeights[[path[[i,1]],y]]*Select[\[Phi]sol,#[[1]]==\[Phi][y] &][[1,2]],{y,Length[locVertices]}];
(*Print[denominator]*);


Print["#####  Transition probability "<>ToString[path[[i,1]]]<>" to "<>ToString[path[[i,2]]]<>"  #####"];
Print[(locWeights[[path[[i,1]],path[[i,2]]]]*Select[\[Phi]sol,#[[1]]==\[Phi][path[[i,2]]] &][[1,2]])/denominator/.\[Beta][_,_]->1//FullSimplify];

prob*=(locWeights[[path[[i,1]],path[[i,2]]]]*Select[\[Phi]sol,#[[1]]==\[Phi][path[[i,2]]] &][[1,2]])/denominator//FullSimplify;
Clear[\[Phi]sol];
]
];
If[OptionValue["draw"],Print[DrawOnGraph[graph,path]]];
Return[prob]
]


(* ::Input::Initialization:: *)
Clear[LaplacianRW2];
Options[LaplacianRW2]={"draw"->False,"print"->False};

LaplacianRW2[graph_,path__,OptionsPattern[]]:=Module[{locSource,locRoot,locWeights,totWeights,locVertices,denominator,prob=1, Z,numerator},
locWeights=WeightedAdjacencyMatrix[graph]//Normal;
totWeights =Total[locWeights,{2}];

locVertices=VertexList@graph;

locRoot = 
 Select[(List@@@PropertyValue[graph,VertexLabels])[[2;;]],StringMatchQ[#[[2]],___~~"ROOT"]&][[All,1]][[1]];
locSource = 
 Select[(List@@@PropertyValue[graph,VertexLabels])[[2;;]],StringMatchQ[#[[2]],___~~"SOURCE"]&][[All,1]][[1]];

If[locRoot =!= path[[1,1]], Print["####  WRONG ROOT  ####"]; Return[NULL]];
If[locSource =!= path[[-1,2]], Print["####  WRONG SOURCE  ####"];Return[NULL]];

Module[{locBC={{},{}},\[Phi],i=1,j,\[Phi]sol},
AppendTo[locBC[[1]],\[Phi][locSource]==1];
AppendTo[locBC[[2]],locSource];

AppendTo[locBC[[1]],\[Phi][path[[i,1]]]==0];
AppendTo[locBC[[2]],path[[i,1]]];

\[Phi]sol=LaplaceEqSolver[graph,locBC,\[Phi]];
(*Print[\[Phi]sol]*);

denominator=Sum[locWeights[[path[[i,1]],y]]*Select[\[Phi]sol,#[[1]]==\[Phi][y] &][[1,2]],{y,Length[locVertices]}];
(*Print[denominator]*);

numerator=locWeights[[path[[i,1]],path[[i,2]]]] * Select[\[Phi]sol,#[[1]]==\[Phi][path[[i,2]]] &][[1,2]]//FullSimplify;

prob*=numerator/denominator//FullSimplify;

Print["#####  Transition probability "<>ToString[path[[i,1]]]<>" to "<>ToString[path[[i,2]]]<>"  #####"];
Print[prob/.\[Beta][_,_]->1//FullSimplify];

Clear[\[Phi]sol,locBC];

For[i=2,i<=Length[path],i++,
(*We need to solve it once with standard BCs at the previous step, i.e. \[Phi][locSource]==1*)
locBC={{\[Phi][locSource]==1},{locSource}};

For[j=1,j<=i-1,j++,
AppendTo[locBC[[1]],\[Phi][path[[j,1]]]==0];
AppendTo[locBC[[2]],path[[j,1]]]
]

(*Print[locBC]*);

Z=VertexAssignment[graph, "excludedVertices"->locBC[[2]]];
Z=ExpectationValue[Z];

If[OptionValue["print"],
Print["#####  Previous Partition Function  #####"];
Print[Z]
];

\[Phi]sol=LaplaceEqSolver[graph,locBC,\[Phi]];
(*Print[\[Phi]sol];*)

denominator=1/Z*Select[\[Phi]sol,#[[1]]==\[Phi][path[[i,1]]] &][[1,2]]//FullSimplify;

Clear[\[Phi]sol, locBC];


(*Then we need to solve it again with updated BC at the current step*)
locBC={{\[Phi][locSource]==denominator^-1},{locSource}};

For[j=1,j<=i,j++,
AppendTo[locBC[[1]],\[Phi][path[[j,1]]]==0];
AppendTo[locBC[[2]],path[[j,1]]]
]

(*Print[locBC]*);

Z=VertexAssignment[graph, "excludedVertices"->locBC[[2]]];
Z=ExpectationValue[Z];

If[OptionValue["print"],
Print["#####  Current Partition Function  #####"];
Print[Z]
];

\[Phi]sol=LaplaceEqSolver[graph,locBC,\[Phi]];
(*Print[\[Phi]sol]*);

Print["#####  Transition probability "<>ToString[path[[i,1]]]<>" to "<>ToString[path[[i,2]]]<>"  #####"];
Print[1/Z*locWeights[[path[[i,1]],path[[i,2]]]]/totWeights[[path[[i,1]]]]*Select[\[Phi]sol,#[[1]]==\[Phi][path[[i,2]]] &][[1,2]]/.\[Beta][_,_]->1//FullSimplify];

prob*=1/Z*locWeights[[path[[i,1]],path[[i,2]]]]/totWeights[[path[[i,1]]]]*Select[\[Phi]sol,#[[1]]==\[Phi][path[[i,2]]] &][[1,2]]//FullSimplify;

Clear[\[Phi]sol,locBC];
]
];
If[OptionValue["draw"],Print[DrawOnGraph[graph,path]]];
Return[prob]
]


(* ::Input::Initialization:: *)
edges = {{1,2},{2,3},{3,1}};
root=2;
source=3;
g=MyGraph[edges,root,source][[1]];

path1={{2,1},{1,3}};
LaplacianRW[g,{{2,1},{1,3}}](*/.\[Beta][_,_]->1*)


(* ::Input::Initialization:: *)
Clear[PathFinder];

PathFinder[graph_]:=Module[{pathList={{}}},
Step[subgraph_]:=Module[{locEdges,locVertices,locWeights,locRoot,locSource,locMoves,newEdges, newRoot,smallerGraph,i},
locEdges = EdgeList@subgraph/.DirectedEdge->List;
locVertices=VertexList@subgraph;
If[Length[locVertices]==1,Return[NULL]];
locWeights=WeightedAdjacencyMatrix[subgraph]//Normal;
locRoot = 
 Select[(List@@@PropertyValue[subgraph,VertexLabels])[[2;;]],StringMatchQ[#[[2]],___~~"ROOT"]&][[All,1]][[1]];
locSource = 
 Select[(List@@@PropertyValue[subgraph,VertexLabels])[[2;;]],StringMatchQ[#[[2]],___~~"SOURCE"]&][[All,1]][[1]];
locMoves=Select[locEdges,#[[1]]==locRoot &][[All]];

(*Print["###  LocMoves  ####"];
Print[locMoves];*);

For[i=1, i<=Length[locMoves],i++,

If[i ==Length[locMoves],
(*True*)If[locMoves[[i,2]]==locSource,
 (*Ture*)pathList=Append[pathList[[2;;]],Append[pathList[[1]],locMoves[[i]]]]; Continue[],
 (*False*)pathList=Prepend[pathList[[2;;]],Append[pathList[[1]],locMoves[[i]]]]
],
(*False*)
If[locMoves[[i,2]]==locSource,
 (*True*)pathList=Append[pathList,Append[pathList[[1]],locMoves[[i]]]];Continue[],
 (*False*)pathList=Prepend[pathList,Append[pathList[[1]],locMoves[[i]]]]
]];

(*Print["###  pathList  ####"];
Print[pathList];*);

newEdges=Select[locEdges,#[[1]]=!=locRoot && #[[2]]=!=locRoot &][[All]];
newRoot = locMoves[[i,2]];
If[Length[newEdges] <= 0,Continue[]];
smallerGraph=MyGraph[newEdges,newRoot,locSource,"undirected"->False][[1]];

(*Print[smallerGraph];*);

Step[smallerGraph]
]
];

Step[graph];
Return[pathList]
]


(* ::Input::Initialization:: *)
Clear[AllLaplacianRWs]

Options[AllLaplacianRWs]={"draw"->False,"print"->False};

AllLaplacianRWs[graph_,OptionsPattern[]]:=Module[{possibleLRW,i,probabilityLRW={}},
possibleLRW=PathFinder[graph];
For[i=1, i<= Length[possibleLRW],i++,
AppendTo[probabilityLRW,LaplacianRW[graph,possibleLRW[[i]],OptionValue["draw"]]];
If[OptionValue["print"],Print[i,") Laplacian RW ",possibleLRW[[i]]," with probability " ,probabilityLRW[[i]]]
]
];
Return[{possibleLRW,probabilityLRW}]
]


(* ::Input::Initialization:: *)
Clear[monoFlatten];
(*monoFlatten[a_?NumericQ]:={};*)
monoFlatten[a_]:={a};
monoFlatten[{a__}]:={{a}};
monoFlatten[{a__,b__}]:={a,b};


Clear[ExtractPaths];
ExtractPaths[exp_]:=Module[{terms,paths={},i},

terms=exp//Expand;
terms=List @@Collect[terms,R[__,Red]];
terms=Outer[List,terms];

For[i=1,i<=Length[terms],i++,
If[MatchQ[terms[[i,1]],R[__,Red]*A_],
AppendTo[paths,terms[[i]]]
]
];
terms=paths//.R[__,Blue]->1//FullSimplify;

Return[terms]
]


(* ::Input::Initialization:: *)
Clear[V];
V[1]:=1;
(*V[0]:=0;*)
V'[a_]:=1


(* ::Input::Initialization:: *)
Clear[VertexAssignment];
Options[VertexAssignment]={"system"->"LERW","print"->False,"excludedVertices"->{},"sourceBC"->1};

VertexAssignment[graph_,OptionsPattern[]]:=Module[{locVertices,locWeights,totWeights,locSource,action,x,y},
Clear[i];
locVertices=VertexList@graph;
locWeights=WeightedAdjacencyMatrix[graph]//Normal;
totWeights =Total[locWeights,{2}];
locSource = 
 Select[(List@@@PropertyValue[graph,VertexLabels])[[2;;]],StringMatchQ[#[[2]],___~~"SOURCE"]&][[All,1]][[1]];

(*LERW*)
If[OptionValue["system"]=="LERW",
If[OptionValue["print"],Print["#####   "<>OptionValue["system"]<>"   #####"]];
action = Product[ If[totWeights[[x]]===0 || MemberQ[OptionValue["excludedVertices"],x],1,V[(1+ Sum[locWeights[[x,y]]/totWeights[[x]] \[Chi]s[y,Subscript[i, x]]\[Chi][x,Subscript[i, x]],{y,Length[locVertices]}] ) ]],{x,Length[locVertices]}];
action*=V[(1+ OptionValue["sourceBC"] \[Chi][locSource,Subscript[i, s]])];(*This is the BC*)
Return[action]];

(*DLA*)
If[OptionValue["system"]=="DLA",If[OptionValue["print"],Print["#####   "<>OptionValue["system"]<>"   #####"]];
Return[
Product[ If[totWeights[[x]]===0 || MemberQ[OptionValue["excludedVertices"],x],1,V[(1+ Product[1+locWeights[[x,y]]/totWeights[[x]] \[Chi]s[y,Subscript[i, x]],{y,Length[locVertices]}] \[Chi][x,Subscript[i, x]]+ Sum[locWeights[[x,y]]/totWeights[[x]] \[Phi]s[y,Subscript[j, x]]\[Phi][x,Subscript[j, x]],{y,Length[locVertices]}])] ],{x,Length[locVertices]}]
]]
]


(* ::Input::Initialization:: *)
ClearAll[\[CapitalSigma]\[Delta]rule]
\[CapitalSigma]\[Delta]rule={\[Delta][a_,b_]^n_/;(!NumericQ[b]&& !MatchQ[b,Subscript[1, __]]):>\[Delta][a,b]^(n-2) \[Delta][a,a],
\[Delta][b_,a_]\[Delta][c_,b_]/;(!NumericQ[b] && !MatchQ[b,Subscript[1, __]]):>\[Delta][c,a],
\[Delta][a_,b_]\[Delta][c_,b_]/;(!NumericQ[b]&& !MatchQ[b,Subscript[1, __]]):>\[Delta][a,c],
\[Delta][a_,a_]/;(MatchQ[a,Subscript[i, __]])/;(a=!=Subscript[i, s]):>n,
\[Delta][a_,a_]/;(MatchQ[a,Subscript[k, _]]):>1};


(* ::Input::Initialization:: *)
ClearAll[\[Delta]ruleExternal]
\[Delta]ruleExternal={\[Delta][a_,a_]/;(NumericQ[a] || a==Subscript[i, s] || MatchQ[a,Subscript[j, __]] || MatchQ[a,Subscript[1, __]]||MatchQ[a,Subscript[k, _]]):>1,
\[Delta][a_,b_]/;(NumericQ[a] ||MatchQ[a,Subscript[k, _]]|| MatchQ[a,Subscript[j, __]]|| MatchQ[a,Subscript[1, _]])/;(a=!=b):>0,
\[Delta][a_,b_]/;(NumericQ[b] ||MatchQ[b,Subscript[k, _]]|| MatchQ[b,Subscript[j, __]]|| MatchQ[b,Subscript[1, _]])/;(a=!=b):>0 };


(* ::Input::Initialization:: *)
Clear[Op];
Op[1]:=1;
Op[0]:=0;
Op'[_]:=1


(* ::Input::Initialization:: *)
Clear[WickContraction];
Options[WickContraction]={"print"->False,"fields"->{\[Chi]}, "endTime"->0(*It is set to 0 for the statical case*)};

WickContraction[A_ +B_,OptionsPattern[]]:=WickContraction[A,"print"->OptionValue["print"],"fields"->OptionValue["fields"], "endTime"->OptionValue["endTime"]]+WickContraction[B,"print"->OptionValue["print"],"fields"->OptionValue["fields"], "endTime"->OptionValue["endTime"]];

WickContraction[A_ +B__+C__,OptionsPattern[]]:=WickContraction[A,"print"->OptionValue["print"],"fields"->OptionValue["fields"], "endTime"->OptionValue["endTime"]]+WickContraction[B+C,"print"->OptionValue["print"],"fields"->OptionValue["fields"], "endTime"->OptionValue["endTime"]];

WickContraction[A_?NumericQ,OptionsPattern[]]:=A;


(*################################################################################
									Expectation Values                             
##############################################################################*)
(*There are two possible contributions for each field: 1) it is not contracted: \[Chi]->0; 2) it is contracted*)
WickContraction[Op[A_] *B_, OptionsPattern[]]:=Module[{locFields={}, starFields={}, deltaFields={},deltaStarFields={},contributions=0,z,zTemp,\[Kappa],j,l,timeIndex},
z=Op[A]B;

Print["###################  Operator found  ##################"];


locFields=OptionValue["fields"];

For[l=1,l<=Length[locFields],l++,
AppendTo[starFields, ToExpression[ToString[locFields[[l]]] <> "s"]];
AppendTo[deltaFields, ToExpression["\[Delta]"<>ToString[locFields[[l]]] ]];
AppendTo[deltaStarFields,ToExpression["\[Delta]"<> ToString[starFields[[l]]] ]];
];(*End of loop to define the fields*)

If[OptionValue["print"],
Print[locFields,starFields,deltaFields,deltaStarFields];
];

For[timeIndex=0,timeIndex<=(OptionValue["endTime"]),timeIndex++,

(*
If[timeIndex==0, 
(*TRUE*)If[OptionValue["endTime"]==0,timeIndex++,Continue[]],
(*FALSE*)z=z//.f_[x_,Subscript[t, timeIndex],a_]->f[x,a];
];*)

If[OptionValue["print"],
Print["###################  Time "<> ToString[timeIndex+1]<>"  ##################"];
Print[z]
];

If[OptionValue["endTime"]!=0,
(*TRUE*)z=z//.f_[x_,Subscript[t, (timeIndex+1)],a_]->f[x,a]
];

For[j=1,j<=100,j++,
For[l=1,l<=Length[locFields],l++,
(*First contribution*)
zTemp=z//.locFields[[l]][j,a_]->0//.starFields[[l]][j,a_]->0;
If[zTemp-z=!=0,
contributions=zTemp;
If[OptionValue["print"],
Print["#### "<>ToString[j]<>": First contribution ####"];
Print[contributions]]
];

(*Second contribution*)
zTemp=z/. locFields[[l]][j,a_]->locFields[[l]][j,a]+\[Kappa] *deltaFields[[l]][j,a];
If[zTemp-z=!=0,
z=D[zTemp,\[Kappa]]/.\[Kappa]->0;
];

zTemp=z/. starFields[[l]][j,a_]->starFields[[l]][j,a]+\[Kappa] *deltaStarFields[[l]][j,a];
If[zTemp-z=!=0,
z=D[zTemp,\[Kappa]]/.\[Kappa]->0;
If[OptionValue["print"],
Print["#### "<>ToString[j]<>": second contribution ####"];
Print[z]
]
];

z=Expand[z];
zTemp=z//.deltaFields[[l]][j,a_]*deltaStarFields[[l]][j,b_](*/;(!NumericQ[a*b]):>*)->\[Delta][a,b];

If[zTemp-z=!=0,
If[OptionValue["print"],
Print["#### Contraction "<>ToString[j]<>" ####"];
Print[z=zTemp]
]
];
z=zTemp/.deltaFields[[l]][j,a_]->0/.deltaStarFields[[l]][j,b_]->0;


If[contributions-z=!=0,
contributions+=z;
If[OptionValue["print"],
Print["#### "<>ToString[j]<>": total contribution ####"];
Print[contributions]]
];

z=contributions;
contributions=0;

];(*End of loop over fields*)
];(*End of loop over space*)

For[l=1,l<=Length[locFields],l++,
z=z/.locFields[[l]][x_,a_]->0;
z=z/.starFields[[l]][x_,a_]->0;
];

z=z//.\[CapitalSigma]\[Delta]rule;
];(*End of loop over time*)

Return[z]
];


(*################################################################################
									Partition Function                             
##############################################################################*)
(*There are two possible contributions for each field: 1) it is not contracted: \[Chi]->0; 2) it is contracted*)

WickContraction[V[A_] *B_, OptionsPattern[]]:=Module[{locFields={}, starFields={}, deltaFields={},deltaStarFields={},contributions=0,z,zTemp,\[Kappa],j,l,timeIndex},
z=V[A]B;

Print["###################  Partition Function  ##################"];


locFields=OptionValue["fields"];

For[l=1,l<=Length[locFields],l++,
AppendTo[starFields, ToExpression[ToString[locFields[[l]]] <> "s"]];
AppendTo[deltaFields, ToExpression["\[Delta]"<>ToString[locFields[[l]]] ]];
AppendTo[deltaStarFields,ToExpression["\[Delta]"<> ToString[starFields[[l]]] ]]
];(*End of loop to define the fields*)

If[OptionValue["print"],
Print[locFields,starFields,deltaFields,deltaStarFields]
];

For[timeIndex=0,timeIndex<=(OptionValue["endTime"]),timeIndex++,

(*If[timeIndex==0, 
(*TRUE*)If[OptionValue["endTime"]==0,timeIndex++,Continue[]],
(*FALSE*)z=z//.f_[x_,Subscript[t, timeIndex],a_]->f[x,a];
];*)

If[OptionValue["print"],
Print["###################  Time "<> ToString[timeIndex+1]<>"  ##################"];
Print["Z before"];
Print[z]
];

If[OptionValue["endTime"]!=0,
(*TRUE*)z=z//.f_[x_,Subscript[t, (timeIndex+1)],a_]->f[x,a]
];

If[OptionValue["print"],
Print["Z After"];
Print[z]
];

For[j=1,j<=100,j++,

For[l=1,l<=Length[locFields],l++,

(*First contribution*)
zTemp=z//.locFields[[l]][j,a_]->0//.starFields[[l]][j,a_]->0;
If[zTemp-z=!=0,
contributions=zTemp;
If[OptionValue["print"],
Print["#### "<>ToString[j]<>": First contribution ####"];
Print[contributions]]
];

(*Second contribution*)
zTemp=z/. locFields[[l]][j,a_]->locFields[[l]][j,a]+\[Kappa] *deltaFields[[l]][j,a];
If[zTemp-z=!=0,
z=D[zTemp,\[Kappa]]/.\[Kappa]->0;
];

zTemp=z/. starFields[[l]][j,a_]->starFields[[l]][j,a]+\[Kappa] *deltaStarFields[[l]][j,a];
If[zTemp-z=!=0,
z=D[zTemp,\[Kappa]]/.\[Kappa]->0;
If[OptionValue["print"],
Print["#### "<>ToString[j]<>": second contribution ####"];
Print[z]
]
];

z=Expand[z];
zTemp=z//.deltaFields[[l]][j,a_]*deltaStarFields[[l]][j,b_](*/;(!NumericQ[a*b]):>*)->\[Delta][a,b];

If[zTemp-z=!=0,
If[OptionValue["print"],
Print["#### Contraction "<>ToString[j]<>" ####"];
Print[z=zTemp]
]
];

z=zTemp/.deltaFields[[l]][j,a_]->0/.deltaStarFields[[l]][j,b_]->0;


If[contributions-z=!=0,
contributions+=z;
If[OptionValue["print"],
Print["#### "<>ToString[j]<>": total contribution ####"];
Print[contributions]]
];

z=contributions;
contributions=0;

](*End of loop over fields*)

];(*End of loop over space*)

For[l=1,l<=Length[locFields],l++,
z=z/.locFields[[l]][x_,a_]->0;
z=z/.starFields[[l]][x_,a_]->0
];

z=z//.\[CapitalSigma]\[Delta]rule;

];(*End of loop over time*)

Return[z]
];

(*
WickContraction[V[A_] *B_, OptionsPattern[]]:=Module[{locFields={}, starFields={}, deltaFields={},deltaStarFields={},contributions=0,z,zTemp,\[Kappa],j,l,timeIndex},

z=V[A]B;

locFields=OptionValue["fields"];

(*Condtruct the fields' names*);
For[l=1,l<=Length[locFields],l++,
AppendTo[starFields, ToExpression[ToString[locFields[[l]]] <> "s"]];
AppendTo[deltaFields, ToExpression["\[Delta]"<>ToString[locFields[[l]]] ]];
AppendTo[deltaStarFields,ToExpression["\[Delta]"<> ToString[starFields[[l]]] ]];
];

(*Work time slice per time slice. If it is a dynamical problem, i.e. endTime!=0, then we transform the problem in a statical one by sending f_[x_,Subscript[t, timeIndex],a_]->f[x,a]*);

For[timeIndex=0,timeIndex<=(OptionValue["endTime"]+1),timeIndex++,

If[timeIndex==0, 
(*TRUE*)If[OptionValue["endTime"]==0,,Continue[]],
(*FALSE*)z=z//.f_[x_,Subscript[t, timeIndex],a_]->f[x,a];
];

For[j=1,j<=100,j++,
For[l=1,l<=Length[locFields],l++,
(*First contribution*)
zTemp=z//.locFields[[l]][j,a_]->0//.starFields[[l]][j,a_]->0;
If[zTemp-z=!=0,
contributions=zTemp;
If[OptionValue["print"],
Print["#### "<>ToString[j]<>": First contribution ####"];
Print[contributions]]
];

(*Second contribution*)
zTemp=z/. locFields[[l]][j,a_]->locFields[[l]][j,a]+\[Kappa] *deltaFields[[l]][j,a];
If[zTemp-z=!=0,
z=D[zTemp,\[Kappa]]/.\[Kappa]->0;
];

zTemp=z/. starFields[[l]][j,a_]->starFields[[l]][j,a]+\[Kappa] *deltaStarFields[[l]][j,a];
If[zTemp-z=!=0,
z=D[zTemp,\[Kappa]]/.\[Kappa]->0;
If[OptionValue["print"],
Print["#### "<>ToString[j]<>": second contribution ####"];
Print[z]
]
];

z=Expand[z];
zTemp=z//.deltaFields[[l]][j,a_]*deltaStarFields[[l]][j,b_](*/;(!NumericQ[a*b]):>*)->\[Delta][a,b];

If[zTemp-z=!=0,
If[OptionValue["print"],
Print["#### Contraction "<>ToString[j]<>" ####"];
Print[z=zTemp]
]
];
z=zTemp/.deltaFields[[l]][j,a_]->0/.deltaStarFields[[l]][j,b_]->0;


If[contributions-z=!=0,
contributions+=z;
If[OptionValue["print"],
Print["#### "<>ToString[j]<>": total contribution ####"];
Print[contributions]]
];

z=contributions;

];
];

For[l=1,l<=Length[locFields],l++,
(*z=z//.\[Chi][x_,a_]*\[Chi]s[x_,b_]/;(!NumericQ[a*b]):>\[Delta][a,b];*)
z=z/.locFields[[l]][x_,a_]->0;
z=z/.starFields[[l]][x_,a_]->0;
];

z=z//.\[CapitalSigma]\[Delta]rule;
];

Return[z]
]*)


(* ::Input::Initialization:: *)
(*
WickContraction[V[A_] *B_, OptionsPattern[]]:=Module[{contributions=0,z,zTemp,\[Kappa],j},
z=V[A]B;
contributions=z;

For[j=1,j<=100,j++,
(*First contribution
zTemp=z//.\[Chi][j,a_]->0//.\[Chi]s[j,a_]->0;
If[zTemp-z=!=0,
z+=zTemp;
];*)

(*Second contribution*)
zTemp=z/. \[Chi][j,a_]->\[Chi][j,a]+\[Kappa] *\[Delta]\[Chi][j,a];
If[zTemp-z=!=0,
z=D[zTemp,\[Kappa]]/.\[Kappa]->0;
];

zTemp=z/. \[Chi]s[j,a_]->\[Chi]s[j,a]+\[Kappa] *\[Delta]\[Chi]s[j,a];
If[zTemp-z=!=0,
z=D[zTemp,\[Kappa]]/.\[Kappa]->0;
If[OptionValue["print"],
Print["#### "<>ToString[j]<>" ####"];
Print[z]
]
];

z=Expand[z];
zTemp=z//.\[Delta]\[Chi][j,a_]*\[Delta]\[Chi]s[j,b_]/;(!NumericQ[a*b]):>\[Delta][a,b];

If[zTemp-z=!=0,
If[OptionValue["print"],
Print["#### Contraction "<>ToString[j]<>" ####"];
Print[z=zTemp]
]
];
z=zTemp/.\[Delta]\[Chi][j,a_]->0/.\[Delta]\[Chi]s[j,b_]->0;


If[contributions-z=!=0,
contributions+=z;
];

z=contributions;

];

z=z/.\[Chi][x_,a_]->0;
z=z/.\[Chi]s[x_,a_]->0;
z=z//.\[CapitalSigma]\[Delta]rule;
Return[z]
]

*)


(* ::Input::Initialization:: *)
Clear[ExpectationValue];
Options[ExpectationValue]={"operator"->1,"print"->False, "fields"->{\[Chi]},"endTime"->1,"draw"->False,"graph"->g, "Rrule"->{R[__]->1}};

ExpectationValue[Z_,OptionsPattern[]]:=Module[{z,terms,graphs={},i},
If[OptionValue["operator"]===1,
(*True*)z=WickContraction[Z,
"print"->OptionValue["print"], 
"fields"->OptionValue["fields"],
"endTime"->OptionValue["endTime"]
],
(*False*)z=WickContraction[Z*Op[OptionValue["operator"]],
"print"->OptionValue["print"], 
"fields"->OptionValue["fields"],
"endTime"->OptionValue["endTime"]
]/WickContraction[Z, "fields"->OptionValue["fields"],"endTime"->OptionValue["endTime"]]
];

z=z//.\[Delta]ruleExternal;
z=z/.n->-1;
z=z/.m->0;

If[OptionValue["draw"],
(*True*)
z=z//.R[a_,b_,c_]^n_->R[a,b,c];
terms=List @@ (z+Zeta[3]);
terms=terms//.\[Beta][__]->1;
terms=DeleteElements[terms,{Zeta[3]}];
terms=Outer[List,terms];
terms=terms//.Times->List;
terms=monoFlatten@@@terms;
terms=terms//.R[a_,b_,c_]->{a,b,c};
(*For[i=1,i<=Length[terms],i++,
terms[[i]]=DeleteElements[terms[[i]],{a_?NumericQ}];
];*)
Print[terms];
z=z/.R[___]->1;

For[i=1,i<=Length[terms],i++,
AppendTo[graphs,DrawOnGraph[OptionValue["graph"],terms[[i,2;;]],"drawOthers"->False]];
Print[graphs[[i]]];
Print[Weight ==terms[[i,1]]];
];,

(*False*)z=z/.OptionValue["Rrule"]];

Return[z]]


(* ::Input::Initialization:: *)
Clear[GeneralizedExpectationValue];
Options[GeneralizedExpectationValue]={"draw"->False,"graph"->1};

GeneralizedExpectationValue[Z_,OptionsPattern[]]:=Module[{z,terms,i,graphs={}},

z=Z//Expand;
(*z=z//.\[Chi][x_,a_]*\[Chi]s[x_,b_]/;(MemberQ[{Subscript[i, s]},a]):>\[Delta][a,b]*);
z=z//.\[Phi][x_,t__]*\[Phi]s[x_,t__]->R[x,\[Phi]];
z=z//.{\[Phi][__]->0,\[Phi]s[__]->0};

z=z//.\[Psi][x_,t__]*\[Psi]s[x_,t__]->R[x,\[Psi]];
z=z//.{\[Psi][__]->0,\[Psi]s[__]->0};

z=z//.\[Chi][x_,t_,a_]*\[Chi]s[x_,t_,b_]/;(!NumericQ[a*b]):>\[Delta][a,b]R[x,\[Chi]];
z=z//.{\[Chi][__]->0,\[Chi]s[__]->0};
z=z//.\[CapitalSigma]\[Delta]rule;
z=z//.\[Delta]ruleExternal;
z=z/.n->-1;
z=z/.m->0;

If[OptionValue["draw"],
(*True*)
z=z/.R[__]->1;
terms=List @@ z;
terms=Abs[Numerator[terms]];
terms=Outer[List,terms];
terms=terms//.Times->List;
terms=monoFlatten@@@terms;
terms=terms//.\[Beta][a_,b_]->{a,b};

For[i=1,i<=Length[terms],i++,
AppendTo[graphs,DrawOnGraph[OptionValue["graph"],terms[[i]],"drawOthers"->False]]
];
Print[graphs],

(*False*)z=z/.R[__]->1];

Return[z]]


(* ::Input::Initialization:: *)
Clear[LERWtransitionProb];
Options[LERWtransitionProb]={"draw"->False,"print"->False};

LERWtransitionProb[graph_,path__,OptionsPattern[]]:=Module[{locSource,locRoot,locWeights,totWeights,locVertices,denominator,prob=1, Z,numerator},
locWeights=WeightedAdjacencyMatrix[graph]//Normal;
totWeights =Total[locWeights,{2}];

locVertices=VertexList@graph;

locRoot = 
 Select[(List@@@PropertyValue[graph,VertexLabels])[[2;;]],StringMatchQ[#[[2]],___~~"ROOT"]&][[All,1]][[1]];
locSource = 
 Select[(List@@@PropertyValue[graph,VertexLabels])[[2;;]],StringMatchQ[#[[2]],___~~"SOURCE"]&][[All,1]][[1]];

If[locRoot =!= path[[1,1]], Print["####  WRONG ROOT  ####"]; Return[NULL]];
If[locSource =!= path[[-1,2]], Print["####  WRONG SOURCE  ####"];Return[NULL]];

Module[{locBC={{},{}},\[Phi],i=1,j},
locBC={{\[Phi][locSource]==1},{locSource}};

For[i=1,i<=Length[path],i++,

Z=VertexAssignment[graph, "excludedVertices"->locBC[[2]]];
Z=ExpectationValue[Z*\[Chi]s[path[[i,1]],1]];

If[OptionValue["print"],
Print["#####  Previous Partition Function  #####"];
Print[Z]
];

denominator=Z//FullSimplify;


(*Then we need to solve it again with updated BC at the current step*)

AppendTo[locBC[[1]],\[Phi][path[[i,1]]]==0];
AppendTo[locBC[[2]],path[[i,1]]];
(*Print[locBC]*);


Z=VertexAssignment[graph, "excludedVertices"->locBC[[2]],"sourceBC"->denominator^-1];
Z=ExpectationValue[Z*\[Chi]s[path[[i,2]],1] ];

If[OptionValue["print"],
Print["#####  Current Partition Function  #####"];
Print[Z]
];

numerator=locWeights[[path[[i,1]],path[[i,2]]]]/totWeights[[path[[i,1]]]]*Z//FullSimplify;

Print["#####  Transition probability "<>ToString[path[[i,1]]]<>" to "<>ToString[path[[i,2]]]<>"  #####"];
Print[numerator/.\[Beta][_,_]->1//FullSimplify];

prob*=numerator//FullSimplify;
]
];
If[OptionValue["draw"],Print[DrawOnGraph[graph,path]]];
Return[prob]
]


(* ::Input::Initialization:: *)
edges = {{1,2},{2,3},{3,1}};
root=2;
source=3;
g=MyGraph[edges,root,source][[1]];

path1={{2,1},{1,3}};
LaplacianRW[g,{{2,1},{1,3}}](*/.\[Beta][_,_]->1*)


(* ::Input::Initialization:: *)
Clear[DynamicLERWaction];
Options[DynamicLERWaction]={"sourceBC"->1};

DynamicLERWaction[graph_,endTime_,OptionsPattern[]]:=Module[{locSource,locRoot,locWeights,totWeights,locVertices,actionTimeSlice,action},
Clear[i,k,j];

locWeights=WeightedAdjacencyMatrix[graph]//Normal;
totWeights =Total[locWeights,{2}];

locVertices=VertexList@graph;

locRoot = 
 Select[(List@@@PropertyValue[graph,VertexLabels])[[2;;]],StringMatchQ[#[[2]],___~~"ROOT"]&][[All,1]][[1]];
locSource = 
 Select[(List@@@PropertyValue[graph,VertexLabels])[[2;;]],StringMatchQ[#[[2]],___~~"SOURCE"]&][[All,1]][[1]];


actionTimeSlice [T_]:= Product[ If[totWeights[[x]]===0 ,1,(*FALSE*)
V[(1+ Sum[locWeights[[x,y]]/totWeights[[x]] R[x,y,Red]\[Phi]s[y,Subscript[t, T+1],Subscript[k, x]]\[Phi][x,Subscript[t, T],Subscript[k, x]]\[Psi]s[x,Subscript[t, T+1],Subscript[j, -1]]\[Chi]s[y,Subscript[t, T],1],{y,Length[locVertices]}]+Sum[locWeights[[x,y]]/totWeights[[x]] R[x,y,Blue]\[Chi]s[y,Subscript[t, T],Subscript[i, x]]\[Chi][x,Subscript[t, T],Subscript[i, x]],{y,Length[locVertices]}]+ \[Psi]s[x,Subscript[t, T+1],Subscript[j, -1]]\[Psi][x,Subscript[t, T],Subscript[j, -1]]) ]],{x,Length[locVertices]}]
V[(1+ OptionValue["sourceBC"] \[Chi][locSource,Subscript[t, T],1])];

action=Product[actionTimeSlice[T],{T,endTime}]Product[V[(1+\[Psi][x,Subscript[t, endTime+1],Subscript[j, -1]])(*This allows the path tracker to be absorbed at the end*) ]V[(1+\[Phi][x,Subscript[t, endTime+1],0])(*This allows the path to end after "endTime" steps*)],{x,Length[locVertices]}];

Return[action]

]


(* ::Input::Initialization:: *)
Clear[DynamicDLAaction];
Options[DynamicDLAaction]={"sourceBC"->1,"excludedVertices"->{}};

DynamicDLAaction[graph_,endTime_,OptionsPattern[]]:=Module[{locSource,locRoot,locWeights,totWeights,locVertices,actionTimeSlice,action},
Clear[i,k,j];

locWeights=WeightedAdjacencyMatrix[graph]//Normal;
totWeights =Total[locWeights,{2}];

locVertices=VertexList@graph;

locRoot = 
 Select[(List@@@PropertyValue[graph,VertexLabels])[[2;;]],StringMatchQ[#[[2]],___~~"ROOT"]&][[All,1]][[1]];
locSource = 
 Select[(List@@@PropertyValue[graph,VertexLabels])[[2;;]],StringMatchQ[#[[2]],___~~"SOURCE"]&][[All,1]][[1]];


actionTimeSlice [T_]:= Product[ If[totWeights[[x]]===0  || MemberQ[OptionValue["excludedVertices"],x],1,(*FALSE*)
V[(1+ Sum[locWeights[[x,y]]R[x,y,Red]\[Phi]s[y,Subscript[t, T+1],Subscript[k, x]]\[Phi][x,Subscript[t, T],Subscript[k, x]]\[Phi]s[x,Subscript[t, T+1],Subscript[k, x]]\[Chi]s[y,Subscript[t, T],1],{y,Length[locVertices]}]+Sum[locWeights[[x,y]]/totWeights[[x]] R[x,y,Blue]\[Chi]s[y,Subscript[t, T],Subscript[i, x]]\[Chi][x,Subscript[t, T],Subscript[i, x]],{y,Length[locVertices]}]+ \[Phi]s[x,Subscript[t, T+1],Subscript[k, x]]\[Phi][x,Subscript[t, T],Subscript[k, x]]) ]],{x,Length[locVertices]}]
V[(1+ OptionValue["sourceBC"] \[Chi][locSource,Subscript[t, T],1])];

action=Product[actionTimeSlice[T],{T,endTime}]Product[V[(1+\[Phi][x,Subscript[t, endTime+1],Subscript[k, x]])(*This allows the path tracker to be absorbed at the end*) ]V[(1+\[Phi][x,Subscript[t, endTime+1],0])(*This allows the path to end after "endTime" steps*)],{x,Length[locVertices]}];

Return[action]

]


(* ::Input::Initialization:: *)
Clear[ModDynamicDLAaction];
Options[ModDynamicDLAaction]={"sourceBC"->1,"excludedVertices"->{},"replicas"->1};

ModDynamicDLAaction[graph_,endTime_,oldSource_,OptionsPattern[]]:=Module[{locSource,locRoot,locWeights,totWeights,locVertices,actionTimeSlice,action},
Clear[i,k,j,\[Sigma],m,M];
M=OptionValue["replicas"];

locWeights=WeightedAdjacencyMatrix[graph]//Normal;
totWeights =Total[locWeights,{2}];

locVertices=VertexList@graph;

locRoot = 
 Select[(List@@@PropertyValue[graph,VertexLabels])[[2;;]],StringMatchQ[#[[2]],___~~"ROOT"]&][[All,1]][[1]];
locSource = 
 Select[(List@@@PropertyValue[graph,VertexLabels])[[2;;]],StringMatchQ[#[[2]],___~~"SOURCE"]&][[All,1]][[1]];


actionTimeSlice [T_]:= Product[ If[totWeights[[x]]===0  || MemberQ[OptionValue["excludedVertices"],x],1,(*FALSE*)
V[(1+ Sum[locWeights[[x,y]]R[x,y,Red]\[Phi]s[y,Subscript[t, T+1],Subscript[k, x]]\[Phi]s[x,Subscript[t, T+1],Subscript[k, x]]\[Chi]s[y,Subscript[t, T],Subscript[1, 0]]
Product[ \[Psi]s[x,Subscript[t, T],Subscript[j, x],Subscript[m, mm]],{mm,M}]\[Phi][x,Subscript[t, T],Subscript[k, x]],{y,Length[locVertices]}]+Sum[locWeights[[x,y]]/totWeights[[x]] R[x,y,Blue]\[Chi]s[y,Subscript[t, T],Subscript[i, x,0]]\[Chi][x,Subscript[t, T],Subscript[i, x,0]],{y,Length[locVertices]}]+ \[Phi]s[x,Subscript[t, T+1],Subscript[k, x]]\[Phi][x,Subscript[t, T],Subscript[k, x]]) ]
Product[ V[1+\[Psi]s[x,Subscript[t, T+1],Subscript[j, x],Subscript[m, mm]]\[Psi][x,Subscript[t, T],Subscript[j, x],Subscript[m, mm]]+Sum[locWeights[[x,y]]/totWeights[[x]] R[x,y,Yellow]\[Chi]s[y,Subscript[t, T],Subscript[i, x],Subscript[m, mm]]\[Chi][x,Subscript[t, T],Subscript[i, x],Subscript[m, mm]],{y,Length[locVertices]}](*This allows to avoid the path while constructing the loops*)],{mm,M}]] ,{x,Length[locVertices]}] 
Product[ Op[\[Sigma](\[Chi]s[locSource,Subscript[t, T],1,Subscript[m, mm]]-\[Chi]s[oldSource,Subscript[t, T],1,Subscript[m, mm]])\[Chi][locSource,Subscript[t, T],1,Subscript[m, mm]](*This allows to compute the Denominator*)],{mm,M}]
V[(1+ OptionValue["sourceBC"] \[Chi][locSource,Subscript[t, T],Subscript[1, 0]])(*This allows to compute the solution to the Laplace eq*)];

action=Product[actionTimeSlice[T],{T,endTime}]Product[V[(1+\[Phi][x,Subscript[t, endTime+1],Subscript[k, x]])(*This allows the path tracker to be absorbed at the end*) ]
Product[ V[(1+\[Psi][x,Subscript[t, endTime+1],Subscript[j, x],Subscript[m, mm]])(*This allows the AUXILIARY path tracker to be absorbed at the end*) ],{mm,M}]
V[(1+\[Phi][x,Subscript[t, endTime+1],0])(*This allows the path to end after "endTime" steps*)],{x,Length[locVertices]}];

Return[action]

]


(* ::Input::Initialization:: *)
Clear[ModWickContraction];
Options[ModWickContraction]={"print"->False,"fields"->{\[Chi]}, "endTime"->0(*It is set to 0 for the statical case*),"replicas"->0};

ModWickContraction[A_ +B_,OptionsPattern[]]:=ModWickContraction[A,"print"->OptionValue["print"],"fields"->OptionValue["fields"], "endTime"->OptionValue["endTime"]]+ModWickContraction[B,"print"->OptionValue["print"],"fields"->OptionValue["fields"], "endTime"->OptionValue["endTime"]];

ModWickContraction[A_ +B__+C__,OptionsPattern[]]:=ModWickContraction[A,"print"->OptionValue["print"],"fields"->OptionValue["fields"], "endTime"->OptionValue["endTime"]]+ModWickContraction[B+C,"print"->OptionValue["print"],"fields"->OptionValue["fields"], "endTime"->OptionValue["endTime"]];

ModWickContraction[A_?NumericQ,OptionsPattern[]]:=A;


(*ModWickContraction[Op[A_] *B_, OptionsPattern[]]:=
ModWickContraction[Op[A_]^nn_ *B_, OptionsPattern[]]*)

(*################################################################################
									Expectation values                            
##############################################################################*)
(*There are two possible contributions for each field: 1) it is not contracted: \[Chi]->0; 2) it is contracted*)

ModWickContraction[Op[A_] *B_, OptionsPattern[]]:=Module[{locFields={}, starFields={}, deltaFields={},deltaStarFields={},contributions=0,z,zTemp,\[Kappa],j,l,r,timeIndex,replicaIndex},
z=Op[A]B;

Print["################### Operators found  ##################"];


locFields=OptionValue["fields"];

For[l=1,l<=Length[locFields],l++,
AppendTo[starFields, ToExpression[ToString[locFields[[l]]] <> "s"]];
AppendTo[deltaFields, ToExpression["\[Delta]"<>ToString[locFields[[l]]] ]];
AppendTo[deltaStarFields,ToExpression["\[Delta]"<> ToString[starFields[[l]]] ]];
];(*End of loop to define the fields*)

If[OptionValue["print"],
Print[locFields,starFields,deltaFields,deltaStarFields];
];

(*Start a loop over time*)
For[timeIndex=0,timeIndex<=(OptionValue["endTime"]),timeIndex++,

If[OptionValue["print"],
Print["###################  Time "<> ToString[timeIndex+1]<>"  ##################"];
Print[z]
];

If[OptionValue["endTime"]!=0,
(*TRUE*)z=z//.f_[x_,Subscript[t, (timeIndex+1)],a__]->f[x,a]
];


(*Start a loop over "replicas"*)
For[replicaIndex=0,replicaIndex<=(OptionValue["replicas"]),replicaIndex++,

If[replicaIndex==0, 
(*TRUE*)If[OptionValue["replicas"]==0,1,Continue[]],
(*FALSE*)z=z//.f_[x_,a_,Subscript[m, (replicaIndex)]]->f[x,a];
];

For[j=1,j<=100,j++,
For[l=1,l<=Length[locFields],l++,
(*First contribution*)
zTemp=z//.locFields[[l]][j,a_]->0//.starFields[[l]][j,a_]->0;
If[zTemp-z=!=0,
contributions=zTemp;
If[OptionValue["print"],
Print["#### "<>ToString[j]<>": First contribution ####"];
Print[contributions]]
];

For[r=1,r<=1,r++,
(*Second contribution*)

zTemp=z/. locFields[[l]][j,a_]->locFields[[l]][j,a]+\[Kappa] *deltaFields[[l]][j,a];
If[zTemp-z=!=0,
z=Factorial[r]^-1*D[zTemp,{\[Kappa],r}]/.\[Kappa]->0;
];

zTemp=z/. starFields[[l]][j,a_]->starFields[[l]][j,a]+\[Kappa] *deltaStarFields[[l]][j,a];
If[zTemp-z=!=0,
z=Factorial[r]^-1*D[zTemp,{\[Kappa],r}]/.\[Kappa]->0;
If[OptionValue["print"],
Print["#### "<>ToString[j]<>": second contribution ####"];
Print[z]
]
];

z=Expand[z];
zTemp=z//.deltaFields[[l]][j,a_]*deltaStarFields[[l]][j,b_](*/;(!NumericQ[a*b]):>*)->\[Delta][a,b];

If[zTemp-z=!=0,
If[OptionValue["print"],
Print["#### Contraction "<>ToString[j]<>" ####"];
Print[z=zTemp]
]
];
z=zTemp/.deltaFields[[l]][j,a_]->0/.deltaStarFields[[l]][j,b_]->0;


If[contributions-z=!=0,
contributions+=z;
If[OptionValue["print"],
Print["#### "<>ToString[j]<>": total contribution ####"];
Print[contributions]]
];

z=contributions;
contributions=0;

];(*End of loop over gaussian orders*)
];(*End of loop over fields*)
];(*End of loop over space*)

For[l=1,l<=Length[locFields],l++,
z=z/.locFields[[l]][x_,a_]->0;
z=z/.starFields[[l]][x_,a_]->0;
];

z=z//.\[CapitalSigma]\[Delta]rule;
contributions=0;
];(*End of loop over replicas*)
];(*End of loop over time*)

Return[z]
];


ModWickContraction[Op[A_]^nn_ *B_, OptionsPattern[]]:=Module[{locFields={}, starFields={}, deltaFields={},deltaStarFields={},contributions=0,z,zTemp,\[Kappa],j,l,r,timeIndex},
z=Op[A]^nn B;

Print["###################  Operator found  ##################"];


locFields=OptionValue["fields"];

For[l=1,l<=Length[locFields],l++,
AppendTo[starFields, ToExpression[ToString[locFields[[l]]] <> "s"]];
AppendTo[deltaFields, ToExpression["\[Delta]"<>ToString[locFields[[l]]] ]];
AppendTo[deltaStarFields,ToExpression["\[Delta]"<> ToString[starFields[[l]]] ]];
];(*End of loop to define the fields*)

If[OptionValue["print"],
Print[locFields,starFields,deltaFields,deltaStarFields];
];

For[timeIndex=0,timeIndex<=(OptionValue["endTime"]),timeIndex++,

(*
If[timeIndex==0, 
(*TRUE*)If[OptionValue["endTime"]==0,timeIndex++,Continue[]],
(*FALSE*)z=z//.f_[x_,Subscript[t, timeIndex],a_]->f[x,a];
];*)

If[OptionValue["print"],
Print["###################  Time "<> ToString[timeIndex+1]<>"  ##################"];
Print[z]
];

If[OptionValue["endTime"]!=0,
(*TRUE*)z=z//.f_[x_,Subscript[t, (timeIndex+1)],a_]->f[x,a]
];

For[j=1,j<=100,j++,
For[l=1,l<=Length[locFields],l++,
(*First contribution*)
zTemp=z//.locFields[[l]][j,a_]->0//.starFields[[l]][j,a_]->0;
If[zTemp-z=!=0,
contributions=zTemp;
If[OptionValue["print"],
Print["#### "<>ToString[j]<>": First contribution ####"];
Print[contributions]]
];

For[r=1,r<=nn,r++,
(*Second contribution*)

zTemp=z/. locFields[[l]][j,a_]->locFields[[l]][j,a]+\[Kappa] *deltaFields[[l]][j,a];
If[zTemp-z=!=0,
z=Factorial[r]^-1*D[zTemp,{\[Kappa],r}]/.\[Kappa]->0;
];

zTemp=z/. starFields[[l]][j,a_]->starFields[[l]][j,a]+\[Kappa] *deltaStarFields[[l]][j,a];
If[zTemp-z=!=0,
z=Factorial[r]^-1*D[zTemp,{\[Kappa],r}]/.\[Kappa]->0;
If[OptionValue["print"],
Print["#### "<>ToString[j]<>": second contribution ####"];
Print[z]
]
];

z=Expand[z];
zTemp=z//.deltaFields[[l]][j,a_]*deltaStarFields[[l]][j,b_](*/;(!NumericQ[a*b]):>*)->\[Delta][a,b];

If[zTemp-z=!=0,
If[OptionValue["print"],
Print["#### Contraction "<>ToString[j]<>" ####"];
Print[z=zTemp]
]
];
z=zTemp/.deltaFields[[l]][j,a_]->0/.deltaStarFields[[l]][j,b_]->0;


If[contributions-z=!=0,
contributions+=z;
If[OptionValue["print"],
Print["#### "<>ToString[j]<>": total contribution ####"];
Print[contributions]]
];

z=contributions;
contributions=0;

];(*End of loop over gaussian orders*)
];(*End of loop over fields*)
];(*End of loop over space*)

For[l=1,l<=Length[locFields],l++,
z=z/.locFields[[l]][x_,a_]->0;
z=z/.starFields[[l]][x_,a_]->0;
];

z=z//.\[CapitalSigma]\[Delta]rule;
];(*End of loop over time*)

Return[z]
];


(*################################################################################
									Partition Function                             
##############################################################################*)
(*There are two possible contributions for each field: 1) it is not contracted: \[Chi]->0; 2) it is contracted*)

ModWickContraction[V[A_] *B_, OptionsPattern[]]:=Module[{locFields={}, starFields={}, deltaFields={},deltaStarFields={},contributions=0,z,zTemp,\[Kappa],j,l,timeIndex},
z=V[A]B;

Print["###################  Partition Function  ##################"];


locFields=OptionValue["fields"];

For[l=1,l<=Length[locFields],l++,
AppendTo[starFields, ToExpression[ToString[locFields[[l]]] <> "s"]];
AppendTo[deltaFields, ToExpression["\[Delta]"<>ToString[locFields[[l]]] ]];
AppendTo[deltaStarFields,ToExpression["\[Delta]"<> ToString[starFields[[l]]] ]]
];(*End of loop to define the fields*)

If[OptionValue["print"],
Print[locFields,starFields,deltaFields,deltaStarFields]
];

For[timeIndex=0,timeIndex<=(OptionValue["endTime"]),timeIndex++,

(*If[timeIndex==0, 
(*TRUE*)If[OptionValue["endTime"]==0,timeIndex++,Continue[]],
(*FALSE*)z=z//.f_[x_,Subscript[t, timeIndex],a_]->f[x,a];
];*)

If[OptionValue["print"],
Print["###################  Time "<> ToString[timeIndex+1]<>"  ##################"];
Print["Z before"];
Print[z]
];

If[OptionValue["endTime"]!=0,
(*TRUE*)z=z//.f_[x_,Subscript[t, (timeIndex+1)],a_]->f[x,a]
];

If[OptionValue["print"],
Print["Z After"];
Print[z]
];

For[j=1,j<=100,j++,

For[l=1,l<=Length[locFields],l++,

(*First contribution*)
zTemp=z//.locFields[[l]][j,a_]->0//.starFields[[l]][j,a_]->0;
If[zTemp-z=!=0,
contributions=zTemp;
If[OptionValue["print"],
Print["#### "<>ToString[j]<>": First contribution ####"];
Print[contributions]]
];

(*Second contribution*)
zTemp=z/. locFields[[l]][j,a_]->locFields[[l]][j,a]+\[Kappa] *deltaFields[[l]][j,a];
If[zTemp-z=!=0,
z=D[zTemp,\[Kappa]]/.\[Kappa]->0;
];

zTemp=z/. starFields[[l]][j,a_]->starFields[[l]][j,a]+\[Kappa] *deltaStarFields[[l]][j,a];
If[zTemp-z=!=0,
z=D[zTemp,\[Kappa]]/.\[Kappa]->0;
If[OptionValue["print"],
Print["#### "<>ToString[j]<>": second contribution ####"];
Print[z]
]
];

z=Expand[z];
zTemp=z//.deltaFields[[l]][j,a_]*deltaStarFields[[l]][j,b_](*/;(!NumericQ[a*b]):>*)->\[Delta][a,b];

If[zTemp-z=!=0,
If[OptionValue["print"],
Print["#### Contraction "<>ToString[j]<>" ####"];
Print[z=zTemp]
]
];

z=zTemp/.deltaFields[[l]][j,a_]->0/.deltaStarFields[[l]][j,b_]->0;


If[contributions-z=!=0,
contributions+=z;
If[OptionValue["print"],
Print["#### "<>ToString[j]<>": total contribution ####"];
Print[contributions]]
];

z=contributions;
contributions=0;

](*End of loop over fields*)

];(*End of loop over space*)

For[l=1,l<=Length[locFields],l++,
z=z/.locFields[[l]][x_,a_]->0;
z=z/.starFields[[l]][x_,a_]->0
];

z=z//.\[CapitalSigma]\[Delta]rule;

];(*End of loop over time*)

Return[z]
];




