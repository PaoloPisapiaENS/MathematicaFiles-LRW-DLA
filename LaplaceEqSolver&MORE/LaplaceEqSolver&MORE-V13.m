(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



SetOptions[$FrontEndSession,NotebookAutoSave->True]
NotebookSave[]


(* ::Input::Initialization:: *)
Clear[MyGraph];
Options[MyGraph]={"undirected" ->True,"label" ->False};
MyGraph[edges__,root_,source_,OptionsPattern[]]:={Module[{locEdges={},i,locWeights={},locRoot=root,locSource=source,p},
Clear[\[Beta]];

For[i=1, i<=(Dimensions@edges)[[1]],i++,
If[OptionValue["undirected"] && edges[[i,2]] =!=locSource && edges[[i,2]] =!=edges[[i,1]] ,
AppendTo[locEdges,edges[[i,2]]->edges[[i,1]]];
AppendTo[locWeights,\[Beta][edges[[i,2]],edges[[i,1]]] ]
];

If[edges[[i,1]]==locSource,Continue[]];

AppendTo[locEdges,edges[[i,1]]->edges[[i,2]]];
AppendTo[locWeights,\[Beta][edges[[i,1]],edges[[i,2]]] ]
];

locEdges=Sort[locEdges,(#1[[1]]<=#2[[1]] &&#1[[2]]<=#2[[1]])||(#1[[1]]<#2[[2]] &&#1[[2]]<=#2[[2]]) &];

p[\[Beta][a_,b_],\[Beta][c_,d_]]:=1/;(a<=c&&b<=c);
p[\[Beta][a_,b_],\[Beta][c_,d_]]:=-1/;(c<=a&&d<=a);
p[\[Beta][a_,b_],\[Beta][c_,d_]]:=1/;(a<d&&b<=d);
p[\[Beta][a_,b_],\[Beta][c_,d_]]:=-1/;(c<b&&d<=b);
locWeights=Sort[locWeights,p];

(*Print[locEdges];
Print[locWeights]*);

If[ OptionValue["label"],
(*True*)Graph[locEdges,EdgeWeight->locWeights, EdgeStyle->Blue, VertexLabels->{locRoot->ToString[locRoot]<>", ROOT",locSource->ToString[locSource]<>", SOURCE","Name"}, EdgeLabels->"EdgeWeight", VertexStyle->{locRoot->Red,locSource->Green,Blue},EdgeShapeFunction->"FilledArrow"],
(*False*)Graph[locEdges,EdgeWeight->locWeights, EdgeStyle->Blue, VertexLabels->{locRoot->ToString[locRoot]<>", ROOT",locSource->ToString[locSource]<>", SOURCE","Name"}, VertexStyle->{locRoot->Red,locSource->Green,Blue},EdgeShapeFunction->"FilledArrow"]]
],
root(*Root*),source(*Source*)}


(* ::Input::Initialization:: *)
Clear[DrawOnGraph];
Options[DrawOnGraph]={"drawOthers"-> True};
DrawOnGraph[graph_,path__,OptionsPattern[]]:=Module[{locEdges,locPathStyle={},locRoot,locSource,i},
locEdges = EdgeList@graph;
locRoot = 
 Select[(List@@@PropertyValue[graph,VertexLabels])[[2;;]],StringMatchQ[#[[2]],___~~"ROOT"]&][[All,1]][[1]];
locSource = 
 Select[(List@@@PropertyValue[graph,VertexLabels])[[2;;]],StringMatchQ[#[[2]],___~~"SOURCE"]&][[All,1]][[1]];

For[i=1, i<=Length[path],i++,
AppendTo[locPathStyle,{path[[i,1]]\[DirectedEdge]path[[i,2]]->path[[i,3]]}];
(*Print[locPathStyle]*)
];
If[OptionValue["drawOthers"],
(*True*)Graph[locEdges,EdgeStyle->Flatten@{locPathStyle,Blue}, VertexLabels->{locRoot->ToString[locRoot]",ROOT",locSource->ToString[locSource]",SOURCE","Name"}, VertexStyle->{locRoot->Red,locSource->Green,Blue},EdgeShapeFunction->"FilledArrow"],
(*False*)Graph[locEdges,EdgeStyle->Flatten@{locPathStyle,White}, VertexLabels->{locRoot->ToString[locRoot]",ROOT",locSource->ToString[locSource]",SOURCE","Name"}, VertexStyle->{locRoot->Red,locSource->Green,Blue},EdgeShapeFunction->"FilledArrow"]
]
]


(* ::Input::Initialization:: *)
path1={{2,1,Red},{1,3,Green}};
DrawOnGraph[g,path1]


Clear[DrawFromExpression];
Options[DrawFromExpression]={"graph"->g,"drawOthers"->False};

DrawFromExpression[exp_,OptionsPattern[]]:=Module[{terms,graphs={},i},
terms=exp//.R[a_,b_,c_]^n_->R[a,b,c]//Expand;
terms=List @@ (terms+Zeta[3]);
terms=terms//.\[Beta][__]->1;
terms=DeleteElements[terms,{Zeta[3]}];
terms=Outer[List,terms];
terms=terms//.Times->List;
terms=monoFlatten@@@terms;
terms=terms//.R[a_,b_,c_]->{a,b,c};
(*For[i=1,i<=Length[terms],i++,
terms[[i]]=DeleteElements[terms[[i]],{a_?NumericQ}];
];*)
Print[terms];

For[i=1,i<=Length[terms],i++,
AppendTo[graphs,DrawOnGraph[OptionValue["graph"],terms[[i,2;;]],"drawOthers"->OptionValue["drawOthers"]]];
Print[graphs[[i]]];
Print[Weight ==terms[[i,1]]];
];
]


(* ::Input::Initialization:: *)
Clear[AugmentedGraph];
AugmentedGraph[graph_]:=Module[{locVertices,locEdges,locPathStyle={},locRoot,locSource,newSource,oldSourceNeighbors,graphPlus,i},

locVertices = VertexList@graph;
locEdges = EdgeList@graph/.DirectedEdge->List;
locRoot = 
 Select[(List@@@PropertyValue[graph,VertexLabels])[[2;;]],StringMatchQ[#[[2]],___~~"ROOT"]&][[All,1]][[1]];
locSource = 
 Select[(List@@@PropertyValue[graph,VertexLabels])[[2;;]],StringMatchQ[#[[2]],___~~"SOURCE"]&][[All,1]][[1]];

newSource=locVertices[[-1]]+1;

(*Add the edge from the oldSource to the newSource*)
AppendTo[locEdges,{locSource,newSource}];

(*Add all the edges from the oldSource to its neighbors*)
oldSourceNeighbors=Select[locEdges, #[[2]]==locSource &];

For[i=1,i<=Length[oldSourceNeighbors],i++,
AppendTo[locEdges,{locSource,oldSourceNeighbors[[i,1]]}]
];

graphPlus =MyGraph[locEdges,locRoot,newSource,"undirected"->False][[1]];

Return[{graphPlus,locSource,newSource}]
]


(* ::Input::Initialization:: *)
Clear[monoFlatten];
(*monoFlatten[a_?NumericQ]:={};*)
monoFlatten[a_]:={a};
monoFlatten[{a__}]:={{a}};
monoFlatten[{a__,b__}]:={a,b};


Clear[ExtractPaths];
ExtractPaths[exp_]:=Module[{terms,paths={},i},

terms=exp//Expand;
terms=List @@Collect[terms,R[__,Red]];
terms=Outer[List,terms];

For[i=1,i<=Length[terms],i++,
If[MatchQ[terms[[i,1]],R[__,Red]*A_],
AppendTo[paths,terms[[i]]]
]
];
terms=paths//.R[__,Blue]->1//FullSimplify;

Return[terms]
]


(* ::Input::Initialization:: *)
Clear[V];
V[1.]:=1.;
V[1]:=1;
(*V[0]:=0;*)
V'[a_]:=1


(* ::Input::Initialization:: *)
Clear[VertexAssignment];
Options[VertexAssignment]={"system"->"LERW","print"->False,"excludedVertices"->{},"sourceBC"->1};

VertexAssignment[graph_,OptionsPattern[]]:=Module[{locVertices,locWeights,totWeights,locSource,action,x,y},
Clear[i];
locVertices=VertexList@graph;
locWeights=WeightedAdjacencyMatrix[graph]//Normal;
totWeights =Total[locWeights,{2}];
locSource = 
 Select[(List@@@PropertyValue[graph,VertexLabels])[[2;;]],StringMatchQ[#[[2]],___~~"SOURCE"]&][[All,1]][[1]];

(*LERW*)
If[OptionValue["system"]=="LERW",
If[OptionValue["print"],Print["#####   "<>OptionValue["system"]<>"   #####"]];
action = Product[ If[totWeights[[x]]===0 || MemberQ[OptionValue["excludedVertices"],x],1,V[(1+ Sum[locWeights[[x,y]]/totWeights[[x]] \[Chi]s[y,Subscript[i, x]]\[Chi][x,Subscript[i, x]],{y,Length[locVertices]}] ) ]],{x,Length[locVertices]}];
action*=V[(1+ OptionValue["sourceBC"] \[Chi][locSource,Subscript[i, s]])];(*This is the BC*)
Return[action]];

(*DLA*)
If[OptionValue["system"]=="DLA",If[OptionValue["print"],Print["#####   "<>OptionValue["system"]<>"   #####"]];
Return[
Product[ If[totWeights[[x]]===0 || MemberQ[OptionValue["excludedVertices"],x],1,V[(1+ Product[1+locWeights[[x,y]]/totWeights[[x]] \[Chi]s[y,Subscript[i, x]],{y,Length[locVertices]}] \[Chi][x,Subscript[i, x]]+ Sum[locWeights[[x,y]]/totWeights[[x]] \[Phi]s[y,Subscript[j, x]]\[Phi][x,Subscript[j, x]],{y,Length[locVertices]}])] ],{x,Length[locVertices]}]
]]
]


(* ::Input::Initialization:: *)
ClearAll[\[CapitalSigma]\[Delta]rule]
\[CapitalSigma]\[Delta]rule={\[Delta][a_,b_]^n_/;(!NumericQ[b]&& !MatchQ[b,Subscript[1, __]]):>\[Delta][a,b]^(n-2) \[Delta][a,a],
\[Delta][b_,a_]\[Delta][c_,b_]/;(!NumericQ[b] && !MatchQ[b,Subscript[1, __]]):>\[Delta][c,a],
\[Delta][a_,b_]\[Delta][c_,b_]/;(!NumericQ[b]&& !MatchQ[b,Subscript[1, __]]):>\[Delta][a,c],
\[Delta][a_,a_]/;(MatchQ[a,Subscript[i, __]])/;(a=!=Subscript[i, s]):>n,
\[Delta][a_,a_]/;(MatchQ[a,Subscript[k, _]]):>1,
\[Delta][a_,a_]/;(MatchQ[a,Subscript[l, _]]):>1,
\[Delta][a_,a_]/;(MatchQ[a,Subscript[jj, _]]):>1,
\[Delta][a_,a_]/;(MatchQ[a,Subscript[ll, _]]):>1};


(* ::Input::Initialization:: *)
ClearAll[\[Delta]ruleExternal]
\[Delta]ruleExternal={\[Delta][a_,a_]/;(NumericQ[a] || a==Subscript[i, s] || MatchQ[a,Subscript[j, __]]|| MatchQ[a,Subscript[jj, __]] || MatchQ[a,Subscript[1, __]]||MatchQ[a,Subscript[k, _]]):>1,
\[Delta][a_,b_]/;(NumericQ[a] ||MatchQ[a,Subscript[k, _]]|| MatchQ[a,Subscript[j, __]]|| MatchQ[a,Subscript[jj, __]] || MatchQ[a,Subscript[1, _]])/;(a=!=b):>0,
\[Delta][a_,b_]/;(NumericQ[b] ||MatchQ[b,Subscript[k, _]]|| MatchQ[b,Subscript[j, __]]|| MatchQ[a,Subscript[jj, __]] || MatchQ[b,Subscript[1, _]])/;(a=!=b):>0 };


(* ::Input::Initialization:: *)
Clear[Op];
Op[1]:=1;
Op[0]:=0;
Op'[_]:=1


(* ::Input::Initialization:: *)
Clear[FieldsNamesGenerator];
FieldsNamesGenerator[fields_]:=
FieldsNamesGenerator[fields]=Block[{locFields={},starFields={},deltaFields={},deltaStarFields={},l},

locFields=fields;

For[l=1,l<=Length[locFields],l++,
AppendTo[starFields, ToExpression[ToString[locFields[[l]]] <> "s"]];
AppendTo[deltaFields, ToExpression["\[Delta]"<>ToString[locFields[[l]]] ]];
AppendTo[deltaStarFields,ToExpression["\[Delta]"<> ToString[starFields[[l]]] ]];
];(*End of loop to define the fields*)

Return[{locFields,starFields,deltaFields,deltaStarFields}]
]


(* ::Input::Initialization:: *)
Clear[WickContractionBlock];
Options[WickContractionBlock]={"print"->False,"fields"->{\[Chi]}, "endTime"->1,"#vertices"->10};

WickContractionBlock[A_ +B_,OptionsPattern[]]:=WickContractionBlock[A,"print"->OptionValue["print"],"fields"->OptionValue["fields"], "endTime"->OptionValue["endTime"],"#vertices"->OptionValue["#vertices"]]+
WickContractionBlock[B,"print"->OptionValue["print"],"fields"->OptionValue["fields"], "endTime"->OptionValue["endTime"],"#vertices"->OptionValue["#vertices"]];

WickContractionBlock[Op[A_ +B_]*C_,OptionsPattern[]]:=WickContractionBlock[Op[A]C,"print"->OptionValue["print"],"fields"->OptionValue["fields"], "endTime"->OptionValue["endTime"],"#vertices"->OptionValue["#vertices"]]+
WickContractionBlock[Op[B]C,"print"->OptionValue["print"],"fields"->OptionValue["fields"], "endTime"->OptionValue["endTime"],"#vertices"->OptionValue["#vertices"]];

WickContractionBlock[A_?NumericQ,OptionsPattern[]]:=A;

(*################################################################################
									Partition Function                             
##############################################################################*)
(*There are two possible contributions for each field: 1) it is not contracted: \[Chi]->0; 2) it is contracted*)

WickContractionBlock[V[A_] *B_, OptionsPattern[]]:=Block[{locFields={}, starFields={}, deltaFields={},deltaStarFields={},contributions=0,z,zTemp1,zTemp2,\[Kappa],jj,l,timeIndex},

z=V[A]B;

(*
If[OptionValue["print"],
Print["###################  Partition Function  ##################"];
];*)

(* Updated version with FieldsNamesGenarator
locFields=OptionValue["fields"];

For[l=1,l<=Length[locFields],l++,
AppendTo[starFields, ToExpression[ToString[locFields[[l]]] <> "s"]];
AppendTo[deltaFields, ToExpression["\[Delta]"<>ToString[locFields[[l]]] ]];
AppendTo[deltaStarFields,ToExpression["\[Delta]"<> ToString[starFields[[l]]] ]]
];(*End of loop to define the fields*)
*)

locFields=OptionValue["fields"][[1]];
starFields=OptionValue["fields"][[2]];
deltaFields=OptionValue["fields"][[3]];
deltaStarFields=OptionValue["fields"][[4]];


(*Start a loop over time*)
For[timeIndex=0,timeIndex<=(OptionValue["endTime"]-1),timeIndex++,

z=z//.f_[x_,Subscript[t, (timeIndex+1)],a_]->f[x,a];

(*Start of loop over fields*)
For[l=1,l<=Length[locFields],l++,

(*Start of loop over space*)
For[jj=1,jj<=OptionValue["#vertices"],jj++,

(*First contribution*)
zTemp1=z//.locFields[[l]][jj,a_]->0//.starFields[[l]][jj,a_]->0;
If[zTemp1-z=!=0,
contributions=zTemp1;
(*Print["First contribution: ",zTemp1];*)
];

(*Second contribution*)
zTemp1=z/. locFields[[l]][jj,a_]->locFields[[l]][jj,a]+\[Kappa] *deltaFields[[l]][jj,a];
If[zTemp1-z=!=0,
zTemp1=D[zTemp1,\[Kappa]]/.\[Kappa]->0;
];

zTemp2=zTemp1/. starFields[[l]][jj,a_]->starFields[[l]][jj,a]+\[Kappa] *deltaStarFields[[l]][jj,a];
If[zTemp2-zTemp1=!=0,
zTemp1=D[zTemp2,\[Kappa]]/.\[Kappa]->0;
];

zTemp1=Expand[zTemp1];
zTemp2=zTemp1//.deltaFields[[l]][jj,a_]*deltaStarFields[[l]][jj,b_](*/;(!NumericQ[a*b]):>*)->\[Delta][a,b];

zTemp1=zTemp2/.deltaFields[[l]][jj,a_]->0/.deltaStarFields[[l]][jj,b_]->0;


If[contributions-zTemp1=!=0,
contributions+=zTemp1;
(*Print["Second contribution: ",zTemp1];*)
];


(*THIRD contribution*)
zTemp1=z/. locFields[[l]][jj,a_]->locFields[[l]][jj,a]+\[Kappa] *deltaFields[[l]][jj,a];
If[zTemp1-z=!=0,
zTemp1=1/2 D[zTemp1,{\[Kappa],2}]/.\[Kappa]->0;
];

zTemp2=zTemp1/. starFields[[l]][jj,a_]->starFields[[l]][jj,a]+\[Kappa] *deltaStarFields[[l]][jj,a];
If[zTemp2-zTemp1=!=0,
zTemp1=D[zTemp2,{\[Kappa],2}]/.\[Kappa]->0;
];

zTemp1=Expand[zTemp1];
zTemp2=zTemp1//.deltaFields[[l]][jj,a_]*deltaStarFields[[l]][jj,b_](*/;(!NumericQ[a*b]):>*)->\[Delta][a,b];
zTemp2=zTemp1//.deltaFields[[l]][jj,a_]*deltaStarFields[[l]][jj,b_]*deltaFields[[l]][jj,a_]*deltaStarFields[[l]][jj,b_](*/;(!NumericQ[a*b]):>*)->\[Delta][a,b]*\[Delta][a,b];

zTemp1=zTemp2/.deltaFields[[l]][jj,a_]->0/.deltaStarFields[[l]][jj,b_]->0;

If[contributions-zTemp1=!=0,
contributions+=zTemp1;
(*Print["Third contribution: ",zTemp1];*)
];

z=contributions;


(*Print["Overall contributions: ",contributions];
Print["################################"];*)

contributions=0;

];(*End of loop over space*)

z=z/.locFields[[l]][x_,a_]->0;
z=z/.starFields[[l]][x_,a_]->0;

];(*End of loop over fields*)

(*For[l=1,l<=Length[locFields],l++,
z=z/.locFields[[l]][x_,a_]->0;
z=z/.starFields[[l]][x_,a_]->0
];*)

z=z//.\[CapitalSigma]\[Delta]rule;

];(*End of loop over time*)

Return[z]
];


(* ::Input::Initialization:: *)
Clear[ExpectationValueBlock];
Options[ExpectationValueBlock]={"operator"->1,"print"->False, "fields"->{\[Chi]},"endTime"->1,"draw"->False,"graph"->g, "Rrule"->{R[__]->1},"external\[Delta]"->True,"n\[Chi]"->-1,"n\[Alpha]"->0};

ExpectationValueBlock[Z_,OptionsPattern[]]:=Block[{Nvertices,z,terms,graphs={},i},

Nvertices=Length[VertexList@OptionValue["graph"]];

If[OptionValue["operator"]===1,
(*True*)z=WickContractionBlock[Z,
"print"->OptionValue["print"], 
"fields"->OptionValue["fields"],
"endTime"->OptionValue["endTime"],
"#vertices"->Nvertices
],
(*False*)z=WickContractionBlock[Z*Op[OptionValue["operator"]],
"print"->OptionValue["print"], 
"fields"->OptionValue["fields"],
"endTime"->OptionValue["endTime"],
"#vertices"->Nvertices
]/WickContractionBlock[Z, "fields"->OptionValue["fields"],"endTime"->OptionValue["endTime"],
"#vertices"->Nvertices]
];

If[OptionValue["external\[Delta]"],
z=z//.\[Delta]ruleExternal];
z=z/.n->OptionValue["n\[Chi]"];
z=z/.m->0;

If[OptionValue["draw"],
(*True*)
z=z//.R[a_,b_,c_]^n_->R[a,b,c];
terms=List @@ (z+Zeta[3]);
terms=terms//.\[Beta][__]->1;
terms=DeleteElements[terms,{Zeta[3]}];
terms=Outer[List,terms];
terms=terms//.Times->List;
terms=monoFlatten@@@terms;
terms=terms//.R[a_,b_,c_]->{a,b,c};
(*For[i=1,i<=Length[terms],i++,
terms[[i]]=DeleteElements[terms[[i]],{a_?NumericQ}];
];*)
Print[terms];
z=z/.R[___]->1;

For[i=1,i<=Length[terms],i++,
AppendTo[graphs,DrawOnGraph[OptionValue["graph"],terms[[i,2;;]],"drawOthers"->False]];
Print[graphs[[i]]];
Print[Weight ==terms[[i,1]]];
];,

(*False*)z=z/.OptionValue["Rrule"]];

Return[z]]


(* ::Input::Initialization:: *)
Clear[LERWtransitionProb];
Options[LERWtransitionProb]={"draw"->False,"print"->False};

LERWtransitionProb[graph_,path__,OptionsPattern[]]:=Module[{locSource,locRoot,locWeights,totWeights,locVertices,denominator,prob=1, Z,numerator},
locWeights=WeightedAdjacencyMatrix[graph]//Normal;
totWeights =Total[locWeights,{2}];

locVertices=VertexList@graph;

locRoot = 
 Select[(List@@@PropertyValue[graph,VertexLabels])[[2;;]],StringMatchQ[#[[2]],___~~"ROOT"]&][[All,1]][[1]];
locSource = 
 Select[(List@@@PropertyValue[graph,VertexLabels])[[2;;]],StringMatchQ[#[[2]],___~~"SOURCE"]&][[All,1]][[1]];

If[locRoot =!= path[[1,1]], Print["####  WRONG ROOT  ####"]; Return[NULL]];
If[locSource =!= path[[-1,2]], Print["####  WRONG SOURCE  ####"];Return[NULL]];

Module[{locBC={{},{}},\[Phi],i=1,j},
locBC={{\[Phi][locSource]==1},{locSource}};

For[i=1,i<=Length[path],i++,

Z=VertexAssignment[graph, "excludedVertices"->locBC[[2]]];
Z=ExpectationValue[Z*\[Chi]s[path[[i,1]],1]];

If[OptionValue["print"],
Print["#####  Previous Partition Function  #####"];
Print[Z]
];

denominator=Z//FullSimplify;


(*Then we need to solve it again with updated BC at the current step*)

AppendTo[locBC[[1]],\[Phi][path[[i,1]]]==0];
AppendTo[locBC[[2]],path[[i,1]]];
(*Print[locBC]*);


Z=VertexAssignment[graph, "excludedVertices"->locBC[[2]],"sourceBC"->denominator^-1];
Z=ExpectationValue[Z*\[Chi]s[path[[i,2]],1] ];

If[OptionValue["print"],
Print["#####  Current Partition Function  #####"];
Print[Z]
];

numerator=locWeights[[path[[i,1]],path[[i,2]]]]/totWeights[[path[[i,1]]]]*Z//FullSimplify;

Print["#####  Transition probability "<>ToString[path[[i,1]]]<>" to "<>ToString[path[[i,2]]]<>"  #####"];
Print[numerator/.\[Beta][_,_]->1//FullSimplify];

prob*=numerator//FullSimplify;
]
];
If[OptionValue["draw"],Print[DrawOnGraph[graph,path]]];
Return[prob]
]


(* ::Input::Initialization:: *)
edges = {{1,2},{2,3},{3,1}};
root=2;
source=3;
g=MyGraph[edges,root,source][[1]];

path1={{2,1},{1,3}};
LaplacianRW[g,{{2,1},{1,3}}](*/.\[Beta][_,_]->1*)


(* ::Input::Initialization:: *)
Clear[Znorm];
Options[Znorm]={"graph"->g,"fields"->FieldsNamesGenerator[{\[Phi],\[Chi]}],"theory"->"LERW","\[Beta]rule"->{\[Beta][__]->1.}};

Znorm[expression_,OptionsPattern[]]:=Block[{locZnorm,excludedVertices,token},

excludedVertices=(expression * 2)/.R[__]->1/.\[Gamma]->1//Expand;
excludedVertices=List @@excludedVertices;
excludedVertices=excludedVertices[[2;;]]; (*Gets rid of the numerical coefficient*)
excludedVertices=excludedVertices/.\[Phi]s[a_,__]->a;
excludedVertices=excludedVertices/.\[Phi]s[a_,__]\[Phi]s[a_,__]->a;
excludedVertices=excludedVertices/.\[Psi]s[a_,__]->a;
excludedVertices=excludedVertices/.\[Psi]s[a_,__]\[Psi]s[a_,__]->a;
excludedVertices=excludedVertices/.\[Xi]s[a_,__]->a;
excludedVertices=excludedVertices/.\[Xi]s[a_,__]\[Xi]s[a_,__]->a;

locZnorm=VertexAssignment[OptionValue["graph"],"system"->"LERW","excludedVertices"->excludedVertices]/.OptionValue["\[Beta]rule"];

ExpectationValueBlock[locZnorm * token,"graph"->OptionValue["graph"],"fields"->OptionValue["fields"]]/.token->1
]


(* ::Input::Initialization:: *)
Clear[FinalDynamicDLAaction];
Options[FinalDynamicDLAaction]={"sourceBC"->1,"excludedVertices"->{},"graph"->g,"endTime"->10};

FinalDynamicDLAaction[OptionsPattern[]]:=Module[{locGraph,locEndTime,locSource,locRoot,locWeights,totWeights,locVertices,actionTimeSlice,action},
Clear[i,k,j,\[Gamma]];

locGraph=OptionValue["graph"];
locEndTime =OptionValue["endTime"];

locWeights=WeightedAdjacencyMatrix[locGraph]//Normal;
totWeights =Total[locWeights,{2}];

locVertices=VertexList@locGraph;

locRoot = 
 Select[(List@@@PropertyValue[locGraph,VertexLabels])[[2;;]],StringMatchQ[#[[2]],___~~"ROOT"]&][[All,1]][[1]];
locSource = 
 Select[(List@@@PropertyValue[locGraph,VertexLabels])[[2;;]],StringMatchQ[#[[2]],___~~"SOURCE"]&][[All,1]][[1]];


actionTimeSlice [T_]:= Product[
If[totWeights[[x]]===0  || MemberQ[OptionValue["excludedVertices"],x],1,
(*FALSE*)V[(1+\[Gamma] Sum[locWeights[[x,y]](R[x,y,Red]\[Phi]s[y,Subscript[t, T+1],Subscript[k, x]]-1)\[Phi]s[x,Subscript[t, T+1],Subscript[k, x]]\[Phi][x,Subscript[t, T],Subscript[k, x]]\[Chi]s[y,Subscript[t, T],1],{y,Length[locVertices]}]+
Sum[locWeights[[x,y]]/totWeights[[x]] R[x,y,Blue]\[Chi]s[y,Subscript[t, T],Subscript[i, x]]\[Chi][x,Subscript[t, T],Subscript[i, x]],{y,Length[locVertices]}]+ \[Phi]s[x,Subscript[t, T+1],Subscript[k, x]]\[Phi][x,Subscript[t, T],Subscript[k, x]]) ]
],{x,Length[locVertices]}]
V[(1+ \[Phi]s[locSource,Subscript[t, T+1],Subscript[k, locSource]]\[Phi][locSource,Subscript[t, T],Subscript[k, locSource]]+OptionValue["sourceBC"] \[Chi][locSource,Subscript[t, T],1])]
(*V[(1+ OptionValue["sourceBC"] \[Chi][locSource,Subscript[t, T],1])]*);

action=Product[actionTimeSlice[T],{T,locEndTime}](*Product[V[(1+\[Phi][x,Subscript[t, locEndTime+1],Subscript[k, x]])(*This allows the path tracker to be absorbed at the end*) ]V[(1+\[Phi][x,Subscript[t, locEndTime+1],0])(*This allows the path to end after "endTime" steps*)],{x,Length[locVertices]}]*);

Return[action]

]


(* ::Input::Initialization:: *)
myFavoriteEdges={{1,2},{1,5},{2,3},{2,5},{5,4},{3,4}};
myFavoriteRoot=1;
myFavoriteSource=4;
myFavoriteGraph=MyGraph[myFavoriteEdges,myFavoriteRoot,myFavoriteSource][[1]]


(* ::Input::Initialization:: *)
fields=FieldsNamesGenerator[{\[Phi],\[Chi]}];
endTime=1;
g=myFavoriteGraph;
Z=FinalDynamicDLAaction["graph"->g,"endTime"->endTime]/.\[Beta][__]->1;
\[Phi]s[1,Subscript[t, 1],Subscript[k, 1]]/Znorm[\[Phi]s[1,Subscript[t, 1],Subscript[k, 1]],"graph"->g,"fields"->fields,"\[Beta]rule"->{\[Beta][__]->1}];
expDLAcorrectNorm=ExpectationValueBlock[Z %,"endTime"->endTime,"fields"->fields,"draw"->False,"Rrule"->{R[__,Blue]->1},"external\[Delta]"->True,"graph"->g]/.\[Gamma]->"\!\(\*SubscriptBox[\(\[Gamma]\), \(1\)]\)"//Expand


(* ::Input::Initialization:: *)
expDLAcorrectNorm/.\[Phi]s[b_,Subscript[t, a_],c_]->\[Phi]s[b,Subscript[t, a-1],Subscript[k, b]];
Replace[%,a_/;(!NumericQ[a]):>a/(Znorm[a,"graph"->g,"fields"->fields,"\[Beta]rule"->{\[Beta][__]->1}]),1];
expDLAcorrectNorm2=ExpectationValueBlock[Z %,"endTime"->endTime,"fields"->fields,"draw"->False,"Rrule"->{R[__,Blue]->1},"graph"->g]/.\[Gamma]->"\!\(\*SubscriptBox[\(\[Gamma]\), \(2\)]\)"/.\[Phi]s[b_,Subscript[t, a_],c_]->\[Phi]s[b,Subscript[t, a-1],Subscript[k, b]];


(* ::Input::Initialization:: *)
fields=FieldsNamesGenerator[{\[Phi],\[Chi]}];
endTime=1;
g=myFavoriteGraph;
Z=FinalDynamicDLAaction["graph"->g,"endTime"->endTime]/.\[Beta][__]->1;
Replace[expDLAcorrectNorm2,a_/;(!NumericQ[a]):>a/(Znorm[a,"graph"->g,"fields"->fields,"\[Beta]rule"->{\[Beta][__]->1}]),1];
expDLAcorrectNorm3=ExpectationValueBlock[Z %,"endTime"->endTime,"fields"->fields,"draw"->False,"Rrule"->{R[__,Blue]->1},"graph"->g]/.\[Gamma]->"\!\(\*SubscriptBox[\(\[Gamma]\), \(3\)]\)"/.\[Phi]s[b_,Subscript[t, a_],c_]->\[Phi]s[b,Subscript[t, a],Subscript[k, b]]/.Subscript[t, a_]->Subscript[t, a-1];


(* ::Input::Initialization:: *)
Clear[ConvergenceKay\[Gamma]];
Options[ConvergenceKay\[Gamma]]={"graph"->g,"fields"->FieldsNamesGenerator[{\[Phi],\[Psi],\[Chi]}],"steps"->10,"precision"->10^-9,"theory"->"DLA","gammaValue"->0.1};

ConvergenceKay\[Gamma][operator_,OptionsPattern[]]:=Module[{Z,Z0,locOperator,locPrecision,loc\[Gamma],exp,i=1,temp},

(*If[OptionValue["theory"]=="DLA",
Z=DynamicDLAactionKay\[Gamma]["graph"->OptionValue[ "graph"],"endTime"->1]/.\[Beta][__]->1.
];*)


Z=DynamicDLAactionKay\[Gamma]["graph"->OptionValue[ "graph"],"endTime"->1]/.\[Beta][__]->1.;
Z0=Z/.\[Gamma]->0;

locOperator= operator;
locPrecision=OptionValue["precision"];
loc\[Gamma]=OptionValue["gammaValue"];

exp=locOperator/(Znorm[locOperator,"graph"->OptionValue["graph"],"fields"->OptionValue["fields"]]);

exp=ExpectationValueBlock[Z exp,"endTime"->1,"fields"->OptionValue["fields"],"Rrule"->{R[__,Blue]->1.},"graph"->OptionValue[ "graph"]];
exp=exp/.Subscript[t, a_]->Subscript[t, a-1]/.\[Gamma]->loc\[Gamma];

(*Purifying step*)
exp=Replace[exp,a_/;(!NumericQ[a]):>a/(Znorm[a,"graph"->OptionValue["graph"],"fields"->OptionValue["fields"]]),1];

exp=ExpectationValueBlock[Z0 exp,"endTime"->1,"fields"->OptionValue["fields"],"Rrule"->{R[__,Blue]->1.},"graph"->OptionValue[ "graph"]];
exp=exp/.Subscript[t, a_]->Subscript[t, a-1]/.\[Gamma]->loc\[Gamma];

Print["########## i=",i,", ",(Coefficient[exp, \[Phi]s[1,Subscript[t, 1],Subscript[k, 1]]]/.R[__]->0)," ############"];

For[i=2,i<=OptionValue["steps"] && (Coefficient[exp, \[Phi]s[1,Subscript[t, 1],Subscript[k, 1]]]/.R[__]->0)>=locPrecision,i++,


exp=Replace[exp,a_/;(!NumericQ[a]):>a/(Znorm[a,"graph"->OptionValue["graph"],"fields"->OptionValue["fields"]]),1];

exp=ExpectationValueBlock[Z exp,"endTime"->1,"fields"->OptionValue["fields"],"Rrule"->{R[__,Blue]->1.},"graph"->OptionValue[ "graph"]];
exp=exp/.Subscript[t, a_]->Subscript[t, a-1]/.\[Gamma]->loc\[Gamma];

(*Purifying step*)

exp=Replace[exp,a_/;(!NumericQ[a]):>a/(Znorm[a,"graph"->OptionValue["graph"],"fields"->OptionValue["fields"]]),1];

exp=ExpectationValueBlock[Z0 exp,"endTime"->1,"fields"->OptionValue["fields"],"Rrule"->{R[__,Blue]->1.},"graph"->OptionValue[ "graph"]];
exp=exp/.Subscript[t, a_]->Subscript[t, a-1]/.\[Gamma]->loc\[Gamma];

Print["########## i=",i,", ",(Coefficient[exp, \[Phi]s[1,Subscript[t, 1],Subscript[k, 1]]]/.R[__]->0)," ############"];
];

Return[exp];
]


(* ::Input::Initialization:: *)
Clear[ConvergenceKay\[Gamma]2];
Options[ConvergenceKay\[Gamma]2]={"graph"->g,"fields"->FieldsNamesGenerator[{\[Phi],\[Psi],\[Chi]}],"steps"->10,"precision"->10^-9,"theory"->"DLA","gammaValue"->0.1};

ConvergenceKay\[Gamma]2[operator_,OptionsPattern[]]:=Module[{Z,Z0,locOperator,locPrecision,loc\[Gamma],exp,i=1,temp},

(*If[OptionValue["theory"]=="DLA",
Z=DynamicDLAactionKay\[Gamma]["graph"->OptionValue[ "graph"],"endTime"->1]/.\[Beta][__]->1.
];*)


Z=DynamicDLAactionKay\[Gamma]2["graph"->OptionValue[ "graph"],"endTime"->1]/.\[Beta][__]->1.;
Z0=Z/.\[Gamma]->0;

locOperator= operator;
locPrecision=OptionValue["precision"];
loc\[Gamma]=OptionValue["gammaValue"];

exp=locOperator/(Znorm[locOperator,"graph"->OptionValue["graph"],"fields"->OptionValue["fields"]]);

exp=ExpectationValueBlock[Z exp,"endTime"->1,"fields"->OptionValue["fields"],"Rrule"->{R[__,Blue]->1.},"graph"->OptionValue[ "graph"]];
exp=exp/.Subscript[t, a_]->Subscript[t, a-1]/.\[Gamma]->loc\[Gamma];

(*Purifying step*)

exp=ExpectationValueBlock[Z0 exp,"endTime"->1,"fields"->OptionValue["fields"],"Rrule"->{R[__,Blue]->1.},"graph"->OptionValue[ "graph"]];
exp=exp/.Subscript[t, a_]->Subscript[t, a-1]/.\[Gamma]->loc\[Gamma];

exp=Replace[exp,a_/;(!NumericQ[a]):>a/(Znorm[a,"graph"->OptionValue["graph"],"fields"->OptionValue["fields"]]),1];
Print["########## i=",i,", ",(Coefficient[exp, \[Phi]s[1,Subscript[t, 1],Subscript[k, 1]]]/.R[__]->0)," ############"];

(*Now iterates untill it converges*)
For[i=2,i<=OptionValue["steps"] && (Coefficient[exp, \[Phi]s[1,Subscript[t, 1],Subscript[k, 1]]]/.R[__]->0)>=locPrecision,i++,


exp=Replace[exp,a_/;(!NumericQ[a]):>a/(Znorm[a,"graph"->OptionValue["graph"],"fields"->OptionValue["fields"]]),1];

exp=ExpectationValueBlock[Z exp,"endTime"->1,"fields"->OptionValue["fields"],"Rrule"->{R[__,Blue]->1.},"graph"->OptionValue[ "graph"]];
exp=exp/.Subscript[t, a_]->Subscript[t, a-1]/.\[Gamma]->loc\[Gamma];

(*Purifying step*)

exp=ExpectationValueBlock[Z0 exp,"endTime"->1,"fields"->OptionValue["fields"],"Rrule"->{R[__,Blue]->1.},"graph"->OptionValue[ "graph"]];
exp=exp/.Subscript[t, a_]->Subscript[t, a-1]/.\[Gamma]->loc\[Gamma];

exp=Replace[exp,a_/;(!NumericQ[a]):>a/(Znorm[a,"graph"->OptionValue["graph"],"fields"->OptionValue["fields"]]),1];


Print["########## i=",i,", ",(Coefficient[exp, \[Phi]s[1,Subscript[t, 1],Subscript[k, 1]]]/.R[__]->0)," ############"];
];

Return[exp];
]


(* ::Input::Initialization:: *)
Clear[ConvergenceKay\[Gamma]2];
Options[ConvergenceKay\[Gamma]2]={"graph"->g,"fields"->FieldsNamesGenerator[{\[Phi],\[Psi],\[Chi]}],"steps"->10,"precision"->10^-9,"theory"->"DLA","gammaValue"->0.1};

ConvergenceKay\[Gamma]2[operator_,OptionsPattern[]]:=Module[{Z,Z0,locOperator,locPrecision,loc\[Gamma],exp,i=1,temp},

(*If[OptionValue["theory"]=="DLA",
Z=DynamicDLAactionKay\[Gamma]["graph"->OptionValue[ "graph"],"endTime"->1]/.\[Beta][__]->1.
];*)


Z=DynamicDLAactionKay\[Gamma]2["graph"->OptionValue[ "graph"],"endTime"->1]/.\[Beta][__]->1.;
Z0=Z/.\[Gamma]->0;

locOperator= operator;
locPrecision=OptionValue["precision"];
loc\[Gamma]=OptionValue["gammaValue"];

exp=locOperator/(Znorm[locOperator,"graph"->OptionValue["graph"],"fields"->OptionValue["fields"]]);

exp=ExpectationValueBlock[Z exp,"endTime"->1,"fields"->OptionValue["fields"],"Rrule"->{R[__,Blue]->1.},"graph"->OptionValue[ "graph"]];
exp=exp/.Subscript[t, a_]->Subscript[t, a-1]/.\[Gamma]->loc\[Gamma];

(*Purifying step*)

exp=ExpectationValueBlock[Z0 exp,"endTime"->1,"fields"->OptionValue["fields"],"Rrule"->{R[__,Blue]->1.},"graph"->OptionValue[ "graph"]];
exp=exp/.Subscript[t, a_]->Subscript[t, a-1]/.\[Gamma]->loc\[Gamma];

exp=Replace[exp,a_/;(!NumericQ[a]):>a/(Znorm[a,"graph"->OptionValue["graph"],"fields"->OptionValue["fields"]]),1];
Print["########## i=",i,", ",(Coefficient[exp, \[Phi]s[1,Subscript[t, 1],Subscript[k, 1]]]/.R[__]->0)," ############"];

(*Now iterates untill it converges*)
For[i=2,i<=OptionValue["steps"] && (Coefficient[exp, \[Phi]s[1,Subscript[t, 1],Subscript[k, 1]]]/.R[__]->0)>=locPrecision,i++,


exp=Replace[exp,a_/;(!NumericQ[a]):>a/(Znorm[a,"graph"->OptionValue["graph"],"fields"->OptionValue["fields"]]),1];

exp=ExpectationValueBlock[Z exp,"endTime"->1,"fields"->OptionValue["fields"],"Rrule"->{R[__,Blue]->1.},"graph"->OptionValue[ "graph"]];
exp=exp/.Subscript[t, a_]->Subscript[t, a-1]/.\[Gamma]->loc\[Gamma];

(*Purifying step*)

exp=ExpectationValueBlock[Z0 exp,"endTime"->1,"fields"->OptionValue["fields"],"Rrule"->{R[__,Blue]->1.},"graph"->OptionValue[ "graph"]];
exp=exp/.Subscript[t, a_]->Subscript[t, a-1]/.\[Gamma]->loc\[Gamma];

exp=Replace[exp,a_/;(!NumericQ[a]):>a/(Znorm[a,"graph"->OptionValue["graph"],"fields"->OptionValue["fields"]]),1];


Print["########## i=",i,", ",(Coefficient[exp, \[Phi]s[1,Subscript[t, 1],Subscript[k, 1]]]/.R[__]->0)," ############"];
];

Return[exp];
]


(* ::Input::Initialization:: *)
Clear[DynamicDLAactionBEST];
Options[DynamicDLAactionBEST]={"sourceBC"->1,"excludedVertices"->{},"graph"->g,"endTime"->1};

DynamicDLAactionBEST[OptionsPattern[]]:=Module[{locGraph,locEndTime,locSource,locRoot,locWeights,totWeights,locVertices,actionTimeSlice,action},
Clear[i,k,j,l,\[Gamma]];

locGraph=OptionValue["graph"];
locEndTime =OptionValue["endTime"];

locWeights=WeightedAdjacencyMatrix[locGraph]//Normal;
totWeights =Total[locWeights,{2}];

locVertices=VertexList@locGraph;

locRoot = 
 Select[(List@@@PropertyValue[locGraph,VertexLabels])[[2;;]],StringMatchQ[#[[2]],___~~"ROOT"]&][[All,1]][[1]];
locSource = 
 Select[(List@@@PropertyValue[locGraph,VertexLabels])[[2;;]],StringMatchQ[#[[2]],___~~"SOURCE"]&][[All,1]][[1]];

actionTimeSlice [T_]:= Product[
If[totWeights[[x]]===0  || MemberQ[OptionValue["excludedVertices"],x],1,
(*FALSE*)V[(1+\[Gamma] Sum[locWeights[[x,y]](R[x,y,Red]\[Phi]s[y,Subscript[t, T+1],Subscript[k, y]]-\[Phi]s[x,Subscript[t, T+1],Subscript[k, x]])\[Psi]s[x,Subscript[t, T],Subscript[jj, x]]\[Chi]s[y,Subscript[t, T],1],{y,Length[locVertices]}]*\[Phi][x,Subscript[t, T],Subscript[k, x]])]
V[(1+Sum[locWeights[[x,y]]/totWeights[[x]] R[x,y,Blue]\[Chi]s[y,Subscript[t, T],Subscript[i, x]]\[Chi][x,Subscript[t, T],Subscript[i, x]],{y,Length[locVertices]}]
(*+COPY and ANNIHILATE\[Phi]s[x,Subscript[t, T+1],Subscript[k, x]]*(\[Phi][x,Subscript[t, T],Subscript[k, x]]\[Phi][x,Subscript[t, T],Subscript[k, x]])/2 NO ANNIHILATION*)
+(*JUST COPY \[Phi]*)\[Phi]s[x,Subscript[t, T+1],Subscript[k, x]]*\[Phi][x,Subscript[t, T],Subscript[k, x]]
+(*JUST COPY \[Phi] from the interaction (just a technicality, not really needed)*)\[Phi]s[x,Subscript[t, T+1],Subscript[k, x]]*\[Psi][x,Subscript[t, T],Subscript[jj, x]]) ]
],{x,Length[locVertices]}]
V[(1+ \[Phi]s[locSource,Subscript[t, T+1],Subscript[k, locSource]]*\[Phi][locSource,Subscript[t, T],Subscript[k, locSource]]+\[Chi][locSource,Subscript[t, T],1])]
(*V[(1+ OptionValue["sourceBC"] \[Chi][locSource,Subscript[t, T],1])]*);

action=Product[actionTimeSlice[T],{T,1,locEndTime}](*Product[V[(1+\[Phi][x,Subscript[t, locEndTime+1],Subscript[k, x]])(*This allows the path tracker to be absorbed at the end*) ]V[(1+\[Phi][x,Subscript[t, locEndTime+1],0])(*This allows the path to end after "endTime" steps*)],{x,Length[locVertices]}]*);

Return[action]

]



