(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



SetOptions[$FrontEndSession,NotebookAutoSave->True]
NotebookSave[]
InitializationValue[$Initialization] = Hold[$HistoryLength = 2];


(* ::Input::Initialization:: *)
Clear[MyGraph];
Options[MyGraph]={"undirected" ->True,"label" ->False,"edgeColor"->{Blue},"myVertexLabel"->{"Name"}};
MyGraph[edges__,root_,source_,OptionsPattern[]]:={Module[{locEdges={},i,locWeights={},locRoot=root,locSource=source,p},
Clear[\[Beta]];

For[i=1, i<=(Dimensions@edges)[[1]],i++,
If[OptionValue["undirected"] && edges[[i,2]] =!=locSource && edges[[i,2]] =!=edges[[i,1]] ,
AppendTo[locEdges,edges[[i,2]]->edges[[i,1]]];
AppendTo[locWeights,\[Beta][edges[[i,2]],edges[[i,1]]] ]
];

If[edges[[i,1]]==locSource,Continue[]];

AppendTo[locEdges,edges[[i,1]]->edges[[i,2]]];
AppendTo[locWeights,\[Beta][edges[[i,1]],edges[[i,2]]] ]
];

locEdges=Sort[locEdges,(#1[[1]]<=#2[[1]] &&#1[[2]]<=#2[[1]])||(#1[[1]]<#2[[2]] &&#1[[2]]<=#2[[2]]) &];

p[\[Beta][a_,b_],\[Beta][c_,d_]]:=1/;(a<=c&&b<=c);
p[\[Beta][a_,b_],\[Beta][c_,d_]]:=-1/;(c<=a&&d<=a);
p[\[Beta][a_,b_],\[Beta][c_,d_]]:=1/;(a<d&&b<=d);
p[\[Beta][a_,b_],\[Beta][c_,d_]]:=-1/;(c<b&&d<=b);
locWeights=Sort[locWeights,p];

(*Print[locEdges];
Print[locWeights]*);

If[ OptionValue["label"],
(*True*)
Graph[locEdges,EdgeWeight->locWeights, EdgeStyle->OptionValue["edgeColor"], VertexLabels->Flatten@{locRoot->ToString[locRoot]<>", ROOT",locSource->ToString[locSource]<>", SOURCE",OptionValue["myVertexLabel"]}, EdgeLabels->"EdgeWeight", VertexStyle->{locRoot->Red,locSource->Green,Blue},EdgeShapeFunction->"FilledArrow"],
(*False*)
Graph[locEdges,EdgeWeight->locWeights, EdgeStyle->OptionValue["edgeColor"], VertexLabels->Flatten@{locRoot->ToString[locRoot]<>", ROOT",locSource->ToString[locSource]<>", SOURCE",OptionValue["myVertexLabel"]}, VertexStyle->{locRoot->Red,locSource->Green,Blue},EdgeShapeFunction->"FilledArrow"]]
],
root(*Root*),source(*Source*)}


(* ::Input::Initialization:: *)
Clear[DrawOnGraph];
Options[DrawOnGraph]={"drawOthers"-> True};
DrawOnGraph[graph_,path__,OptionsPattern[]]:=Module[{locEdges,locPathStyle={},locRoot,locSource,i},
locEdges = EdgeList@graph;
locRoot = 
 Select[(List@@@PropertyValue[graph,VertexLabels])[[2;;]],StringMatchQ[#[[2]],___~~"ROOT"]&][[All,1]][[1]];
locSource = 
 Select[(List@@@PropertyValue[graph,VertexLabels])[[2;;]],StringMatchQ[#[[2]],___~~"SOURCE"]&][[All,1]][[1]];

For[i=1, i<=Length[path],i++,
AppendTo[locPathStyle,{path[[i,1]]\[DirectedEdge]path[[i,2]]->path[[i,3]]}];
(*Print[locPathStyle]*)
];
If[OptionValue["drawOthers"],
(*True*)Graph[locEdges,EdgeStyle->Flatten@{locPathStyle,Blue}, VertexLabels->{locRoot->ToString[locRoot]",ROOT",locSource->ToString[locSource]",SOURCE","Name"}, VertexStyle->{locRoot->Red,locSource->Green,Blue},EdgeShapeFunction->"FilledArrow"],
(*False*)Graph[locEdges,EdgeStyle->Flatten@{locPathStyle,White}, VertexLabels->{locRoot->ToString[locRoot]",ROOT",locSource->ToString[locSource]",SOURCE","Name"}, VertexStyle->{locRoot->Red,locSource->Green,Blue},EdgeShapeFunction->"FilledArrow"]
]
]


(* ::Input::Initialization:: *)
path1={{2,1,Red},{1,3,Green}};
DrawOnGraph[g,path1]


Clear[DrawFromExpression];
Options[DrawFromExpression]={"graph"->g,"drawOthers"->False};

DrawFromExpression[exp_,OptionsPattern[]]:=Module[{terms,graphs={},i},
terms=exp//.R[a_,b_,c_]^n_->R[a,b,c]//Expand;
terms=List @@ (terms+Zeta[3]);
terms=terms//.\[Beta][__]->1;
terms=DeleteElements[terms,{Zeta[3]}];
terms=Outer[List,terms];
terms=terms//.Times->List;
terms=monoFlatten@@@terms;
terms=terms//.R[a_,b_,c_]->{a,b,c};
(*For[i=1,i<=Length[terms],i++,
terms[[i]]=DeleteElements[terms[[i]],{a_?NumericQ}];
];*)
Print[terms];

For[i=1,i<=Length[terms],i++,
AppendTo[graphs,DrawOnGraph[OptionValue["graph"],terms[[i,2;;]],"drawOthers"->OptionValue["drawOthers"]]];
Print[graphs[[i]]];
Print[Weight ==terms[[i,1]]];
];
]


(* ::Input::Initialization:: *)
ClearAll[GraphWithAbsorption];
Options[GraphWithAbsorption]={"print"->False};

GraphWithAbsorption[graph_,OptionsPattern[]]:=Module[{locVertices,locEdges,locPathStyle={},locRoot,locSource,edgeColor={},graphPlus,i},

locVertices = VertexList@graph;
locEdges = EdgeList@graph/.DirectedEdge->List;
locRoot = 
 Select[(List@@@PropertyValue[graph,VertexLabels])[[2;;]],StringMatchQ[#[[2]],___~~"ROOT"]&][[All,1]][[1]];
locSource = 
 Select[(List@@@PropertyValue[graph,VertexLabels])[[2;;]],StringMatchQ[#[[2]],___~~"SOURCE"]&][[All,1]][[1]];


If[OptionValue["print"],Print["\nStaring vertex list"],locVertices];

(* Add the absorption vertex to the vertex list*)
AppendTo[locVertices,Length[locVertices]+1];

If[OptionValue["print"],Print["\nNew vertex list"],locVertices];


If[OptionValue["print"],Print["\nStarting edge list"],locEdges];

(* Add the edges to the absorption vertex to the edge list*)
For[i=1,i<Length[locVertices],i++,
AppendTo[locEdges,{locVertices[[i]],Length[locVertices]}];
];
edgeColor={_\[DirectedEdge]Length[locVertices]->Red,Blue};

If[OptionValue["print"],Print["\nNew edge list"],locEdges];

graphPlus =MyGraph[locEdges,locRoot,locSource,"undirected"->False,"edgeColor"->edgeColor,"myVertexLabel"->{Length[locVertices]->"ABS","Name"}][[1]];

Return[graphPlus]
]


(* ::Input::Initialization:: *)
Clear[monoFlatten];
(*monoFlatten[a_?NumericQ]:={};*)
monoFlatten[a_]:={a};
monoFlatten[{a__}]:={{a}};
monoFlatten[{a__,b__}]:={a,b};


Clear[ExtractPaths];
ExtractPaths[exp_]:=Module[{terms,paths={},i},

terms=exp//Expand;
terms=List @@Collect[terms,R[__,Red]];
terms=Outer[List,terms];

For[i=1,i<=Length[terms],i++,
If[MatchQ[terms[[i,1]],R[__,Red]*A_],
AppendTo[paths,terms[[i]]]
]
];
terms=paths//.R[__,Blue]->1//FullSimplify;

Return[terms]
]


(* ::Input::Initialization:: *)
Clear[V];
V[1.]:=1.;
V[1]:=1;
(*V[0]:=0;*)
V'[a_]:=1


(* ::Input::Initialization:: *)
Clear[VertexAssignment];
Options[VertexAssignment]={"system"->"LERW","print"->False,"excludedVertices"->{},"sourceBC"->1};

VertexAssignment[graph_,OptionsPattern[]]:=Module[{locVertices,locWeights,totWeights,locSource,action,x,y},
Clear[i];
locVertices=VertexList@graph;
locWeights=WeightedAdjacencyMatrix[graph]//Normal;
totWeights =Total[locWeights,{2}];
locSource = 
 Select[(List@@@PropertyValue[graph,VertexLabels])[[2;;]],StringMatchQ[#[[2]],___~~"SOURCE"]&][[All,1]][[1]];

(*LERW*)
If[OptionValue["system"]=="LERW",
If[OptionValue["print"],Print["#####   "<>OptionValue["system"]<>"   #####"]];
action = Product[ If[totWeights[[x]]===0 || MemberQ[OptionValue["excludedVertices"],x],1,V[(1+ Sum[locWeights[[x,y]]/totWeights[[x]] \[Chi]s[y,Subscript[i, x]]\[Chi][x,Subscript[i, x]],{y,Length[locVertices]}] ) ]],{x,Length[locVertices]}];
action*=V[(1+ OptionValue["sourceBC"] \[Chi][locSource,Subscript[i, s]])];(*This is the BC*)
Return[action]];

(*DLA*)
If[OptionValue["system"]=="DLA",If[OptionValue["print"],Print["#####   "<>OptionValue["system"]<>"   #####"]];
Return[
Product[ If[totWeights[[x]]===0 || MemberQ[OptionValue["excludedVertices"],x],1,V[(1+ Product[1+locWeights[[x,y]]/totWeights[[x]] \[Chi]s[y,Subscript[i, x]],{y,Length[locVertices]}] \[Chi][x,Subscript[i, x]]+ Sum[locWeights[[x,y]]/totWeights[[x]] \[Phi]s[y,Subscript[j, x]]\[Phi][x,Subscript[j, x]],{y,Length[locVertices]}])] ],{x,Length[locVertices]}]
]]
]


(* ::Input::Initialization:: *)
ClearAll[\[CapitalSigma]\[Delta]rule]
\[CapitalSigma]\[Delta]rule={\[Delta][a_,b_]^n_/;(!NumericQ[b]&& !MatchQ[b,Subscript[1, __]]):>\[Delta][a,b]^(n-2) \[Delta][a,a],
\[Delta][b_,a_]\[Delta][c_,b_]/;(!NumericQ[b] && !MatchQ[b,Subscript[1, __]]):>\[Delta][c,a],
\[Delta][a_,b_]\[Delta][c_,b_]/;(!NumericQ[b]&& !MatchQ[b,Subscript[1, __]]):>\[Delta][a,c],
\[Delta][a_,a_]/;(MatchQ[a,Subscript[i, __]])/;(a=!=Subscript[i, s]):>n,
\[Delta][a_,a_]/;(MatchQ[a,Subscript[k, _]]):>1,
\[Delta][a_,a_]/;(MatchQ[a,Subscript[l, _]]):>1,
\[Delta][a_,a_]/;(MatchQ[a,Subscript[jj, _]]):>1,
\[Delta][a_,a_]/;(MatchQ[a,Subscript[ll, _]]):>1};


(* ::Input::Initialization:: *)
ClearAll[\[Delta]ruleExternal]
\[Delta]ruleExternal={\[Delta][a_,a_]/;(NumericQ[a] || a==Subscript[i, s] || MatchQ[a,Subscript[j, __]]|| MatchQ[a,Subscript[jj, __]] || MatchQ[a,Subscript[1, __]]||MatchQ[a,Subscript[k, _]]):>1,
\[Delta][a_,b_]/;(NumericQ[a] ||MatchQ[a,Subscript[k, _]]|| MatchQ[a,Subscript[j, __]]|| MatchQ[a,Subscript[jj, __]] || MatchQ[a,Subscript[1, _]])/;(a=!=b):>0,
\[Delta][a_,b_]/;(NumericQ[b] ||MatchQ[b,Subscript[k, _]]|| MatchQ[b,Subscript[j, __]]|| MatchQ[a,Subscript[jj, __]] || MatchQ[b,Subscript[1, _]])/;(a=!=b):>0 };


(* ::Input::Initialization:: *)
Clear[Op];
Op[1]:=1;
Op[0]:=0;
Op'[_]:=1


(* ::Input::Initialization:: *)
Clear[FieldsNamesGenerator];
FieldsNamesGenerator[fields_]:=
FieldsNamesGenerator[fields]=Block[{locFields={},starFields={},deltaFields={},deltaStarFields={},l},

locFields=fields;

For[l=1,l<=Length[locFields],l++,
AppendTo[starFields, ToExpression[ToString[locFields[[l]]] <> "s"]];
AppendTo[deltaFields, ToExpression["\[Delta]"<>ToString[locFields[[l]]] ]];
AppendTo[deltaStarFields,ToExpression["\[Delta]"<> ToString[starFields[[l]]] ]];
];(*End of loop to define the fields*)

Return[{locFields,starFields,deltaFields,deltaStarFields}]
]


(* ::Input::Initialization:: *)
Clear[WickContractionBlock];
Options[WickContractionBlock]={"print"->False,"fields"->FieldsNamesGenerator[{\[Chi]}], "endTime"->1,"#vertices"->10};

WickContractionBlock[A_ +B_,OptionsPattern[]]:=WickContractionBlock[A,"print"->OptionValue["print"],"fields"->OptionValue["fields"], "endTime"->OptionValue["endTime"],"#vertices"->OptionValue["#vertices"]]+
WickContractionBlock[B,"print"->OptionValue["print"],"fields"->OptionValue["fields"], "endTime"->OptionValue["endTime"],"#vertices"->OptionValue["#vertices"]];

WickContractionBlock[Op[A_ +B_]*C_,OptionsPattern[]]:=WickContractionBlock[Op[A]C,"print"->OptionValue["print"],"fields"->OptionValue["fields"], "endTime"->OptionValue["endTime"],"#vertices"->OptionValue["#vertices"]]+
WickContractionBlock[Op[B]C,"print"->OptionValue["print"],"fields"->OptionValue["fields"], "endTime"->OptionValue["endTime"],"#vertices"->OptionValue["#vertices"]];

WickContractionBlock[A_?NumericQ,OptionsPattern[]]:=A;

(*################################################################################
									Partition Function                             
##############################################################################*)
(*There are two possible contributions for each field: 1) it is not contracted: \[Chi]->0; 2) it is contracted*)

WickContractionBlock[V[A_] *B_, OptionsPattern[]]:=Block[{locFields={}, starFields={}, deltaFields={},deltaStarFields={},contributions=0,z,zTemp1,zTemp2,\[Kappa],jj,l,timeIndex},

z=V[A]B;

(*
If[OptionValue["print"],
Print["###################  Partition Function  ##################"];
];*)

(* Updated version with FieldsNamesGenarator
locFields=OptionValue["fields"];

For[l=1,l<=Length[locFields],l++,
AppendTo[starFields, ToExpression[ToString[locFields[[l]]] <> "s"]];
AppendTo[deltaFields, ToExpression["\[Delta]"<>ToString[locFields[[l]]] ]];
AppendTo[deltaStarFields,ToExpression["\[Delta]"<> ToString[starFields[[l]]] ]]
];(*End of loop to define the fields*)
*)

locFields=OptionValue["fields"][[1]];
starFields=OptionValue["fields"][[2]];
deltaFields=OptionValue["fields"][[3]];
deltaStarFields=OptionValue["fields"][[4]];


(*Start a loop over time*)
For[timeIndex=0,timeIndex<=(OptionValue["endTime"]-1),timeIndex++,

z=z//.f_[x__,Subscript[t, (timeIndex+1)],a__]->f[x,a];

(*Start of loop over fields*)
For[l=1,l<=Length[locFields],l++,

(*Start of loop over space*)
For[jj=1,jj<=OptionValue["#vertices"],jj++,

(*First contribution*)
zTemp1=z//.locFields[[l]][jj,a_]->0//.starFields[[l]][jj,a_]->0;
If[zTemp1-z=!=0,
contributions=zTemp1;
If[OptionValue["print"],Print["First contribution: ",zTemp1]];
];

(*Second contribution*)
zTemp1=z/. locFields[[l]][jj,a_]->locFields[[l]][jj,a]+\[Kappa] *deltaFields[[l]][jj,a];
If[zTemp1-z=!=0,
zTemp1=D[zTemp1,\[Kappa]]/.\[Kappa]->0;
];

zTemp2=zTemp1/. starFields[[l]][jj,a_]->starFields[[l]][jj,a]+\[Kappa] *deltaStarFields[[l]][jj,a];
If[zTemp2-zTemp1=!=0,
zTemp1=D[zTemp2,\[Kappa]]/.\[Kappa]->0;
];

zTemp1=Expand[zTemp1];
zTemp2=zTemp1//.deltaFields[[l]][jj,a_]*deltaStarFields[[l]][jj,b_](*/;(!NumericQ[a*b]):>*)->\[Delta][a,b];

zTemp1=zTemp2/.deltaFields[[l]][jj,a_]->0/.deltaStarFields[[l]][jj,b_]->0;


If[contributions-zTemp1=!=0,
contributions+=zTemp1;
If[OptionValue["print"],Print["Second contribution: ",zTemp1]];
];


(*THIRD contribution*)
zTemp1=z/. locFields[[l]][jj,a_]->locFields[[l]][jj,a]+\[Kappa] *deltaFields[[l]][jj,a];
If[zTemp1-z=!=0,
zTemp1=1/2 D[zTemp1,{\[Kappa],2}]/.\[Kappa]->0;
];

zTemp2=zTemp1/. starFields[[l]][jj,a_]->starFields[[l]][jj,a]+\[Kappa] *deltaStarFields[[l]][jj,a];
If[zTemp2-zTemp1=!=0,
zTemp1=D[zTemp2,{\[Kappa],2}]/.\[Kappa]->0;
];

zTemp1=Expand[zTemp1];
zTemp2=zTemp1//.deltaFields[[l]][jj,a_]*deltaStarFields[[l]][jj,b_](*/;(!NumericQ[a*b]):>*)->\[Delta][a,b];
zTemp2=zTemp1//.deltaFields[[l]][jj,a_]*deltaStarFields[[l]][jj,b_]*deltaFields[[l]][jj,a_]*deltaStarFields[[l]][jj,b_](*/;(!NumericQ[a*b]):>*)->\[Delta][a,b]*\[Delta][a,b];

zTemp1=zTemp2/.deltaFields[[l]][jj,a_]->0/.deltaStarFields[[l]][jj,b_]->0;

If[contributions-zTemp1=!=0,
contributions+=zTemp1;
If[OptionValue["print"],Print["Third contribution: ",zTemp1]];
];

z=contributions;


If[OptionValue["print"],Print["Overall contributions: ",contributions];
Print["################################"]];

contributions=0;

];(*End of loop over space*)

z=z/.locFields[[l]][x_,a_]->0;
z=z/.starFields[[l]][x_,a_]->0;

];(*End of loop over fields*)

(*For[l=1,l<=Length[locFields],l++,
z=z/.locFields[[l]][x_,a_]->0;
z=z/.starFields[[l]][x_,a_]->0
];*)

z=z//.\[CapitalSigma]\[Delta]rule;

];(*End of loop over time*)

Return[z]
];


(* ::Input::Initialization:: *)
Clear[ExpectationValueBlock];
Options[ExpectationValueBlock]={"operator"->1,"print"->False, "fields"->FieldsNamesGenerator[{\[Chi]}],"endTime"->1,"draw"->False,"graph"->g, "Rrule"->{R[__]->1},"external\[Delta]"->True,"n\[Chi]"->-1,"n\[Alpha]"->0};

ExpectationValueBlock[Z_,OptionsPattern[]]:=Block[{Nvertices,z,terms,graphs={},ii},

Nvertices=Length[VertexList@OptionValue["graph"]];

If[OptionValue["operator"]===1,
(*True*)z=WickContractionBlock[Z,
"print"->OptionValue["print"], 
"fields"->OptionValue["fields"],
"endTime"->OptionValue["endTime"],
"#vertices"->Nvertices
],
(*False*)z=WickContractionBlock[Z*Op[OptionValue["operator"]],
"print"->OptionValue["print"], 
"fields"->OptionValue["fields"],
"endTime"->OptionValue["endTime"],
"#vertices"->Nvertices
]/WickContractionBlock[Z, "fields"->OptionValue["fields"],"endTime"->OptionValue["endTime"],
"#vertices"->Nvertices]
];

If[OptionValue["external\[Delta]"],
z=z//.\[Delta]ruleExternal];
z=z/.n->OptionValue["n\[Chi]"];
z=z/.m->0;

If[OptionValue["draw"],
(*True*)
z=z//.R[a_,b_,c_]^n_->R[a,b,c];
terms=List @@ (z+Zeta[3]);
terms=terms//.\[Beta][__]->1;
terms=DeleteElements[terms,{Zeta[3]}];
terms=Outer[List,terms];
terms=terms//.Times->List;
terms=monoFlatten@@@terms;
terms=terms//.R[a_,b_,c_]->{a,b,c};
(*For[i=1,i<=Length[terms],i++,
terms[[i]]=DeleteElements[terms[[i]],{a_?NumericQ}];
];*)
Print[terms];
z=z/.R[___]->1;

For[ii=1,ii<=Length[terms],ii++,
AppendTo[graphs,DrawOnGraph[OptionValue["graph"],terms[[ii,2;;]],"drawOthers"->False]];
Print[graphs[[ii]]];
Print[Weight ==terms[[ii,1]]];
];,

(*False*)
z=z/.OptionValue["Rrule"]];

Return[z]]


(* ::Input::Initialization:: *)
ClearAll[PathFinder];

PathFinder[graph_]:=Module[{pathList={{}}},
Step[subgraph_]:=Module[{locEdges,locVertices,locWeights,locRoot,locSource,locMoves,newEdges, newRoot,smallerGraph,i},
locEdges = EdgeList@subgraph/.DirectedEdge->List;
locVertices=VertexList@subgraph;
If[Length[locVertices]==1,Return[NULL]];
locWeights=WeightedAdjacencyMatrix[subgraph]//Normal;
locRoot = 
 Select[(List@@@PropertyValue[subgraph,VertexLabels])[[2;;]],StringMatchQ[#[[2]],___~~"ROOT"]&][[All,1]][[1]];
locSource = 
 Select[(List@@@PropertyValue[subgraph,VertexLabels])[[2;;]],StringMatchQ[#[[2]],___~~"SOURCE"]&][[All,1]][[1]];
locMoves=Select[locEdges,#[[1]]==locRoot &][[All]];

(*Print["###  LocMoves  ####"];
Print[locMoves];*);

For[i=1, i<=Length[locMoves],i++,

If[i ==Length[locMoves],
(*True*)If[locMoves[[i,2]]==locSource,
 (*Ture*)pathList=Append[pathList[[2;;]],Append[pathList[[1]],locMoves[[i]]]]; Continue[],
 (*False*)pathList=Prepend[pathList[[2;;]],Append[pathList[[1]],locMoves[[i]]]]
],
(*False*)
If[locMoves[[i,2]]==locSource,
 (*True*)pathList=Append[pathList,Append[pathList[[1]],locMoves[[i]]]];Continue[],
 (*False*)pathList=Prepend[pathList,Append[pathList[[1]],locMoves[[i]]]]
]];

(*Print["###  pathList  ####"];
Print[pathList];*);

newEdges=Select[locEdges,#[[1]]=!=locRoot && #[[2]]=!=locRoot &][[All]];
newRoot = locMoves[[i,2]];
If[Length[newEdges] <= 0,Continue[]];
smallerGraph=MyGraph[newEdges,newRoot,locSource,"undirected"->False][[1]];

(*Print[smallerGraph];*);

Step[smallerGraph]
]
];

Step[graph];
Return[pathList]
]


(* ::Input::Initialization:: *)
Clear[LaplaceEqSolver];
Options[LaplaceEqSolver]={"BC"->{{},{}} , "selectSolution"->0,"print"->False};

LaplaceEqSolver[graph_,OptionsPattern[]]:=Module[{locVertices,locWeights,totWeights,locRoot,locSource,locBC,equations,variables={},x,solution},
Clear[\[CapitalPhi]];

locVertices = VertexList@graph;
locWeights=WeightedAdjacencyMatrix[graph]//Normal;
totWeights =Total[locWeights,{2}];

locRoot = 
 Select[(List@@@PropertyValue[graph,VertexLabels])[[2;;]],StringMatchQ[#[[2]],___~~"ROOT"]&][[All,1]][[1]];
locSource = 
 Select[(List@@@PropertyValue[graph,VertexLabels])[[2;;]],StringMatchQ[#[[2]],___~~"SOURCE"]&][[All,1]][[1]];

locBC=OptionValue["BC"];

If[FreeQ[locBC[[2]],locSource],
AppendTo[locBC[[1]],\[CapitalPhi][locSource]== 1];
AppendTo[locBC[[2]],locSource];
];

If[FreeQ[locBC[[2]],locRoot],
AppendTo[locBC[[1]],\[CapitalPhi][locRoot]==0];
AppendTo[locBC[[2]],locRoot];
];
If[OptionValue["print"],
Print["Boundary conditions: ",locBC];
];


equations =locBC[[1]] ;

For[x=1,x<=Length[locVertices],x++,
AppendTo[variables,\[CapitalPhi][x]];

If[MemberQ[locBC[[2]],x]  ,Continue[]];

If[totWeights[[x]]===0,
(* TRUE *)
AppendTo[equations, \[CapitalPhi][x]==0],
(* False *)
AppendTo[equations, \[CapitalPhi][x]==FullSimplify[Sum[locWeights[[x,y]]/totWeights[[x]] \[CapitalPhi][y],{y,Length[locVertices]}]]]
];
If[OptionValue["print"],
Print["############## x=",x," ##############"];
Print["Equations: ",equations];
Print["Variables: ",variables]
];
];


solution=Flatten@Solve[equations,variables]/. Rule->List;

If[OptionValue["selectSolution"]!=0,(*True*)
solution=Select[solution,#[[1]]==\[CapitalPhi][OptionValue["selectSolution"]] &][[1,2]]
];

Return[solution]
]


(* ::Input::Initialization:: *)
Clear[LaplacianRW];
Options[LaplacianRW]={"print"->False,"draw"->False};

LaplacianRW[graph_,path__,OptionsPattern[]]:=Module[{locGraph,locPath,locSource,locRoot,locWeights,locVertices,denominator,prob=1},
locGraph=graph;
locPath=path;

locWeights=WeightedAdjacencyMatrix[locGraph]//Normal;
locVertices=VertexList@locGraph;
locRoot = 
 Select[(List@@@PropertyValue[locGraph,VertexLabels])[[2;;]],StringMatchQ[#[[2]],___~~"ROOT"]&][[All,1]][[1]];
locSource = 
 Select[(List@@@PropertyValue[locGraph,VertexLabels])[[2;;]],StringMatchQ[#[[2]],___~~"SOURCE"]&][[All,1]][[1]];
If[locRoot =!= locPath[[1,1]], Print["####  WRONG ROOT  ####"]; Return[NULL]];
If[locSource =!= locPath[[-1,2]], Print["####  WRONG SOURCE  ####"];Return[NULL]];

Module[{locBC={{},{}},i,\[Phi]sol},
AppendTo[locBC[[1]],\[CapitalPhi][locSource]==1];
AppendTo[locBC[[2]],locSource];

For[i=1,i<=Length[locPath],i++,
If[OptionValue["print"],
Print["####################################################"];
Print["#####################  Step #",i,"  #####################"]
];

AppendTo[locBC[[1]],\[CapitalPhi][locPath[[i,1]]]==0];
AppendTo[locBC[[2]],locPath[[i,1]]];
If[OptionValue["print"],Print["\nLocal BC: ",locBC]];

\[Phi]sol=LaplaceEqSolver[locGraph,"BC"->locBC];
If[OptionValue["print"],Print["\nSolution: ",\[Phi]sol]];

denominator=Sum[locWeights[[locPath[[i,1]],y]]*Select[\[Phi]sol,#[[1]]==\[CapitalPhi][y] &][[1,2]],{y,Length[locVertices]}];
If[OptionValue["print"],Print["\nDenominator: ",denominator]];

If[OptionValue["print"],
Print["#####  Transition probability ",locPath[[i,1]]," to ",locPath[[i,2]],"  #####"];
Print[(locWeights[[locPath[[i,1]],locPath[[i,2]]]]*Select[\[Phi]sol,#[[1]]==\[CapitalPhi][locPath[[i,2]]] &][[1,2]])/denominator/.\[Beta][_,_]->1//FullSimplify]
];

prob*=(locWeights[[locPath[[i,1]],locPath[[i,2]]]]*Select[\[Phi]sol,#[[1]]==\[CapitalPhi][locPath[[i,2]]] &][[1,2]])/denominator//FullSimplify;
Clear[\[Phi]sol];
]
];
If[OptionValue["draw"],Print[DrawOnGraph[locGraph,locPath]]];
Return[prob]
]


(* ::Input::Initialization:: *)
Clear[LERWtransitionProb];
Options[LERWtransitionProb]={"draw"->False,"print"->False};

LERWtransitionProb[graph_,path__,OptionsPattern[]]:=Module[{locSource,locRoot,locWeights,totWeights,locVertices,denominator,prob=1, Z,numerator},
locWeights=WeightedAdjacencyMatrix[graph]//Normal;
totWeights =Total[locWeights,{2}];

locVertices=VertexList@graph;

locRoot = 
 Select[(List@@@PropertyValue[graph,VertexLabels])[[2;;]],StringMatchQ[#[[2]],___~~"ROOT"]&][[All,1]][[1]];
locSource = 
 Select[(List@@@PropertyValue[graph,VertexLabels])[[2;;]],StringMatchQ[#[[2]],___~~"SOURCE"]&][[All,1]][[1]];

If[locRoot =!= path[[1,1]], Print["####  WRONG ROOT  ####"]; Return[NULL]];
If[locSource =!= path[[-1,2]], Print["####  WRONG SOURCE  ####"];Return[NULL]];

Module[{locBC={{},{}},\[Phi],ii=1,j},
locBC={{\[Phi][locSource]==1},{locSource}};

For[ii=1,ii<=Length[path],ii++,

Z=VertexAssignment[graph, "excludedVertices"->locBC[[2]]];

If[OptionValue["print"],
Print["############################################\*
StyleBox[\(##\)]####"];
Print["#####  Previous uncontracted partition function  #####"];
Print[Z]
];

Z=ExpectationValueBlock[Z*\[Chi]s[path[[ii,1]],Subscript[i, s]],"endTime"->1,"draw"->False,"Rrule"->{R[__,Blue]->1},"external\[Delta]"->True,"graph"->graph];

If[OptionValue["print"],
Print["#####  Previous CONTRACTED partition function  #####"];
Print[Z]
];

denominator=Z//FullSimplify;


(*Then we need to solve it again with updated BC at the current step*)
AppendTo[locBC[[1]],\[Phi][path[[ii,1]]]==0];
AppendTo[locBC[[2]],path[[ii,1]]];
(*Print[locBC]*);


Z=VertexAssignment[graph, "excludedVertices"->locBC[[2]],"sourceBC"->denominator^-1];
Z=ExpectationValueBlock[Z*\[Chi]s[path[[ii,2]],Subscript[i, s]],"endTime"->1,"draw"->False,"Rrule"->{R[__,Blue]->1},"external\[Delta]"->True,"graph"->graph];

If[OptionValue["print"],
Print["#####  Current Partition Function  #####"];
Print[Z]
];

numerator=locWeights[[path[[ii,1]],path[[ii,2]]]]/totWeights[[path[[ii,1]]]]*Z//FullSimplify;
If[OptionValue["print"],
Print["#####  Transition probability ",path[[ii,1]]," to ",path[[ii,2]],"  #####"];
Print[numerator/.\[Beta][_,_]->1//FullSimplify]
];

prob*=numerator//FullSimplify;
]
];
If[OptionValue["draw"],Print[DrawOnGraph[graph,path]]];
Return[prob]
]


(* ::Input::Initialization:: *)
Clear[Znorm];
Options[Znorm]={"graph"->g,"fields"->{\[Phi],\[Xi],\[Chi]},"theory"->"LERW","\[Beta]rule"->{\[Beta][__]->1.}};

Znorm[expression_,OptionsPattern[]]:=Block[{locZnorm,excludedVertices,token},

excludedVertices=(expression * 2)/.R[__]->1/.\[Gamma]->1//Expand;
excludedVertices=List @@excludedVertices;
excludedVertices=excludedVertices[[2;;]]; (*Gets rid of the numerical coefficient*)
excludedVertices=excludedVertices/.SuperStar[\[Phi]][a_,__]->a;
excludedVertices=excludedVertices/.\!\(
\*SubsuperscriptBox[\((
\*SuperscriptBox[\(\[Phi]\), \(*\)])\), \(a_, __\), \(2\)] -> a\);
excludedVertices=excludedVertices/.SuperStar[\[Psi]][a_,__]->a;
excludedVertices=excludedVertices/.\!\(
\*SubsuperscriptBox[\((
\*SuperscriptBox[\(\[Psi]\), \(*\)])\), \(a_, __\), \(n_\)] -> a\);
excludedVertices=excludedVertices/.SuperStar[\[Xi]][a_,__]->a;
excludedVertices=excludedVertices/.\!\(
\*SubsuperscriptBox[\((
\*SuperscriptBox[\(\[Xi]\), \(*\)])\), \(a_, __\), \(n_\)] -> a\);

locZnorm=VertexAssignment[OptionValue["graph"],"system"->"LERW","excludedVertices"->excludedVertices]/.OptionValue["\[Beta]rule"];

ExpectationValueBlock[locZnorm * token,"graph"->OptionValue["graph"],"fields"->OptionValue["fields"]]/.token->1
]


(* ::Input::Initialization:: *)
Clear[FinalDynamicDLAaction];
Options[FinalDynamicDLAaction]={"sourceBC"->1,"excludedVertices"->{},"graph"->g,"endTime"->10};

FinalDynamicDLAaction[OptionsPattern[]]:=Module[{locGraph,locEndTime,locSource,locRoot,locWeights,totWeights,locVertices,actionTimeSlice,action},
Clear[i,k,j,\[Gamma]];

locGraph=OptionValue["graph"];
locEndTime =OptionValue["endTime"];

locWeights=WeightedAdjacencyMatrix[locGraph]//Normal;
totWeights =Total[locWeights,{2}];

locVertices=VertexList@locGraph;

locRoot = 
 Select[(List@@@PropertyValue[locGraph,VertexLabels])[[2;;]],StringMatchQ[#[[2]],___~~"ROOT"]&][[All,1]][[1]];
locSource = 
 Select[(List@@@PropertyValue[locGraph,VertexLabels])[[2;;]],StringMatchQ[#[[2]],___~~"SOURCE"]&][[All,1]][[1]];


actionTimeSlice [T_]:= Product[
If[totWeights[[x]]===0  || MemberQ[OptionValue["excludedVertices"],x],1,
(*FALSE*)V[(1+\[Gamma] Sum[locWeights[[x,y]](R[x,y,Red]\[Phi]s[y,Subscript[t, T+1],Subscript[k, x]]-1)\[Phi]s[x,Subscript[t, T+1],Subscript[k, x]]\[Phi][x,Subscript[t, T],Subscript[k, x]]\[Chi]s[y,Subscript[t, T],1],{y,Length[locVertices]}]+
Sum[locWeights[[x,y]]/totWeights[[x]] R[x,y,Blue]\[Chi]s[y,Subscript[t, T],Subscript[i, x]]\[Chi][x,Subscript[t, T],Subscript[i, x]],{y,Length[locVertices]}]+ \[Phi]s[x,Subscript[t, T+1],Subscript[k, x]]\[Phi][x,Subscript[t, T],Subscript[k, x]]) ]
],{x,Length[locVertices]}]
V[(1+ \[Phi]s[locSource,Subscript[t, T+1],Subscript[k, locSource]]\[Phi][locSource,Subscript[t, T],Subscript[k, locSource]]+OptionValue["sourceBC"] \[Chi][locSource,Subscript[t, T],1])]
(*V[(1+ OptionValue["sourceBC"] \[Chi][locSource,Subscript[t, T],1])]*);

action=Product[actionTimeSlice[T],{T,locEndTime}](*Product[V[(1+\[Phi][x,Subscript[t, locEndTime+1],Subscript[k, x]])(*This allows the path tracker to be absorbed at the end*) ]V[(1+\[Phi][x,Subscript[t, locEndTime+1],0])(*This allows the path to end after "endTime" steps*)],{x,Length[locVertices]}]*);

Return[action]

]


(* ::Input::Initialization:: *)
myFavoriteEdges={{1,2},{1,5},{2,3},{2,5},{5,4},{3,4}};
myFavoriteRoot=1;
myFavoriteSource=4;
myFavoriteGraph=MyGraph[myFavoriteEdges,myFavoriteRoot,myFavoriteSource][[1]]


(* ::Input::Initialization:: *)
fields=FieldsNamesGenerator[{\[Phi],\[Chi]}];
endTime=1;
g=myFavoriteGraph;
Z=FinalDynamicDLAaction["graph"->g,"endTime"->endTime]/.\[Beta][__]->1;
\[Phi]s[1,Subscript[t, 1],Subscript[k, 1]]/Znorm[\[Phi]s[1,Subscript[t, 1],Subscript[k, 1]],"graph"->g,"fields"->fields,"\[Beta]rule"->{\[Beta][__]->1}];
expDLAcorrectNorm=ExpectationValueBlock[Z %,"endTime"->endTime,"fields"->fields,"draw"->False,"Rrule"->{R[__,Blue]->1},"external\[Delta]"->True,"graph"->g]/.\[Gamma]->"\!\(\*SubscriptBox[\(\[Gamma]\), \(1\)]\)"//Expand


(* ::Input::Initialization:: *)
expDLAcorrectNorm/.\[Phi]s[b_,Subscript[t, a_],c_]->\[Phi]s[b,Subscript[t, a-1],Subscript[k, b]];
Replace[%,a_/;(!NumericQ[a]):>a/(Znorm[a,"graph"->g,"fields"->fields,"\[Beta]rule"->{\[Beta][__]->1}]),1];
expDLAcorrectNorm2=ExpectationValueBlock[Z %,"endTime"->endTime,"fields"->fields,"draw"->False,"Rrule"->{R[__,Blue]->1},"graph"->g]/.\[Gamma]->"\!\(\*SubscriptBox[\(\[Gamma]\), \(2\)]\)"/.\[Phi]s[b_,Subscript[t, a_],c_]->\[Phi]s[b,Subscript[t, a-1],Subscript[k, b]];


(* ::Input::Initialization:: *)
fields=FieldsNamesGenerator[{\[Phi],\[Chi]}];
endTime=1;
g=myFavoriteGraph;
Z=FinalDynamicDLAaction["graph"->g,"endTime"->endTime]/.\[Beta][__]->1;
Replace[expDLAcorrectNorm2,a_/;(!NumericQ[a]):>a/(Znorm[a,"graph"->g,"fields"->fields,"\[Beta]rule"->{\[Beta][__]->1}]),1];
expDLAcorrectNorm3=ExpectationValueBlock[Z %,"endTime"->endTime,"fields"->fields,"draw"->False,"Rrule"->{R[__,Blue]->1},"graph"->g]/.\[Gamma]->"\!\(\*SubscriptBox[\(\[Gamma]\), \(3\)]\)"/.\[Phi]s[b_,Subscript[t, a_],c_]->\[Phi]s[b,Subscript[t, a],Subscript[k, b]]/.Subscript[t, a_]->Subscript[t, a-1];



